# 16_트리거(Trigger)

> 테이블에 어떤 신호가 가해졌을 때, 미리 정해놓은 활동이 자동으로 실행되는 것

트리거(Trigger)는 `방아쇠`라는 의미를 가지고 있다.

DB에서 트리거란 테이블에 어떤 이벤트가 발생했을 때, 미리 정해놓은 활동들이 자동으로 실행되는 것을 의미한다.

즉, 어떤 테이블에 특정 이벤트(insert, update, delete)가 발생했을 때, 연쇄적으로 추가 실행하고자 하는 쿼리 작업들을 자동적으로 수행할 수 있게끔 트리거로 등록해두는 것이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/65c4f063-4928-4d7e-91a4-35a3fbd9a2a8)

<br>

## 1. 왜 쓸까?

> 데이터베이스의 유연성과 자동화를 향상시키기 위해서

### 1) 데이터 무결성 유지

트리거를 사용하여 데이터베이스에 데이터를 삽입하거나 갱신할 때 해당 데이터에 대한 특정 조건을 검사하고, 조건을 만족시키지 않을 때 해당 쿼리문의 실행을 거부할 수 있다.

<br>

### 2) 데이터 일관성 유지

하나의 테이블이 갱신될 때, 그와 연관된 테이블도 갱신되어야 하는 경우, 트리거를 사용함으로써 연쇄적으로 갱신이 이뤄지게 하여 여러 테이블 간의 데이터 일관성을 유지할 수 있다.

<br>

### 3) 자동 로깅 및 감시

트리거를 사용하면 특정 이벤트가 발생했을 때, 로그를 작성하거나 특정 동작을 감시할 수 있다. 이를 통해 데이터 변경 이력을 추적하거나 보안적인 이슈 사항들을 체크할 수 있다.

특정 테이블에서 데이터를 삭제했을 때, 해당 데이터를 백업 테이블로 옮기는 트리거를 사용하여 백업 테이블에 기존의 데이터를 보관할 수 있음

이와 같은 로그를 트리거를 사용하여 자동으로 기록하게 해놓으면 게임에서 해킹이 발생했을 때, 아이템의 이동 경로를 추적하여 해킹에 대한 복구를 할 수 있다.

<br>

### 4) 비즈니스 로직 적용

특정 이벤트가 발생했을 때, 추가적으로 같이 발생해야 하는 이벤트들을 자동적으로 수행하게 하여, 비즈니스 로직을 구현할 수 있게 해준다.

<br>

## 2. 트리거의 종류

트리거의 종류에는 문장 트리거와 행 트리거가 존재한다.

### 1) 문장 트리거

INSERT, UPDATE, DELETE와 같은 DML에 대하여 한 번만 실행되는 트리거로, 삽입/갱신/삭제되는 행의 수의 상관 없이 각 트랜잭션에 대해 명령문 레벨의 트리거가 한 번 실행되는 것을 말한다.

#### (1) BEFORE / AFTER + DML(INSERT, UPDATE, DELETE)

- BEFORE + 트리거 : 쿼리 이벤트가 동작하기 전에 트리거됨. 미리 데이터를 확인할 수도 있음
- AFTER + 트리거 : 쿼리 이벤트가 작동한 후에 트리거됨.

#### (2) INSTEAD OF + 트리거

원래 문장 대신 트리거를 수행하기 위해 사용하는 문법

<br>

### 2) 행 트리거

조건에 만족하는 테이블의 개별 행에 대해 각각 실행되는 트리거.

변경 전, 변경 후의 행을 각 각 OLD, NEW라는 가상의 줄 변수를 사용하여 읽을 수 있다.

- INSERT: 새롭게 삽입되는 것이니 NEW만 존재하여 사용 가능
- UPDATE: 기존의 데이터를 갱신한 것이니 OLD와 NEW 둘 다 존재하여 사용 가능
- DELETE: 데이터를 삭제하는 것이니 OLD만 존재하여 사용 가능

<br>

## 3. 트리거 사용

### 1) 기본 구조

```SQL
DELIMITER $$
	CREATE TRIGGER [트리거 이름]
	{BEFORE | AFTER} {INSERT | UPDATE| DELETE }
	ON [테이블 이름] FOR EACH ROW
	BEGIN
		-- 트리거 내용 (행 트리거)
	END
DELIMITER;
```

<br>

### 2) 예시

```SQL
DELIMITER $$

-- sales_table에 UPDATE 이후에 조건에 부합하는 모든 행에 적용되는 update_item이라는 트리거를 생성
CREATE TRIGGER update_item
AFTER UPDATE  -- UPDATE 이후 적용
ON sales_table -- 판매 테이블에
FOR EACH ROW -- 아래 조건에 부합하는 것을 모든 행에 적용한다

-- 트리거시 실행되는 쿼리문(행 쿼리)
BEGIN
  -- NEW의 할인율과 OLD의 할인율이 다르면 item_table의 할인율 데이터에서 OLD의 할인율과 같은 값들을 NEW의 할인율로 갱신한다
  IF NEW.discount_rate != OLD.discount_rate THEN
    UPDATE item_table SET discount_rate = NEW.discount_rate WHERE discount_rate = OLD.discount_rate;
  END IF;
END $$

DELIMITER ;
```

#### (1) 트리거 실행

```SQL
UPDATE sales_table SET ... WHERE ...; -- sales_table에 update 이후에 대한 트리거를 적용시켜놓았으니 update문을 실행해 트리거링 
```

#### (2) 트리거 확인

```SQL
show triggers;
```

#### (3) 트리거 삭제

```SQL
DELETE triggers;
```

<br>

## 4. 트리거와 프로시저

트리거는 연쇄적으로 여러 쿼리를 자동적으로 적용하기 위해 사용하고, 프로시저는 일련의 쿼리 집합을 사용하기 위한 함수로서 사용한다.

얼핏 보면 여러 쿼리문을 적용시키기 위해 사용한다는 점에서 동일한 개념처럼 보이지만, 차이가 존재한다.

### 1) 작업; 자동 실행 vs. 명시적 호출

- 트리거는 등록만 해두면 적용한 테이블에 변화가 일어났을 때 `자동적으로 실행`된다.
- 반면에 프로시저는 CALL 명령어를 통해 `사용자가 호출`을 해줘야 한다.

### 2) 용도; 무결성 vs. 로직

둘 다 반복적인 작업을 처리하기 위해 사용한다는 공통점이 있지만 용도에 차이가 있다.

- 트리거는 매 이벤트마다 `동일하게` 처리되어야 하는 경우에 사용한다.
  - 주로 데이터의 무결성을 유지하고, 자동화된 데이터 조작 작업을 할 때 사용한다.

- 반면에 프로시저는 복잡한 비즈니스 로직을 처리하거나 작업의 특정 단계를 재사용하기 위해 사용한다.
  - 트리거에 비해 매 이벤트마다 수행 작업이 동일하지 않은 경우, 변칙성이 있는 경우에 사용하는 것이 더 적합하다.
  - 예를 들어, 우수 회원을 선정한다고 할 때, 일반적으로 특정 기간의 실적을 바탕으로 처리하는데 이 때는 트리거를 사용하는 것보다 프로시저를 사용해서 처리해야 한다.


### 3) 트리거가 적용된 테이블

- 트리거가 실행된 테이블을 트리거를 통해서 수정하려고 한다면 에러가 발생한다.
- 따라서 이때는 프로시저를 사용하는 것이 적절하다.