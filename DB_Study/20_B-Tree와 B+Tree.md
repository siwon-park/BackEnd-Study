# 20_B-Tree와 B+Tree

> B; Balanced (균형 잡힌)

<br>

## 1. B-Tree

비 마이너스 트리라고 읽는 사람도 있지만 -는 하이픈(-)이다. 따라서 공식 명칭은 `비 트리(B Tree)`이다.

트리의 노드가 한쪽으로만 치우치지 않도록 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬하여 `균형 잡힌 상태(balanced)`를 유지한다.

### 1) 특징

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ae118f66-c86b-4cd1-9da0-3c250bbb696b)

- 자식을 최대 M개 가질 수 있는 B 트리를 M차 B트리라고 한다.
  - ex) 3차 B트리는 최대 3개의 자식을 가질 수 있다. (위 캡처가 3차 B트리)
  - 각 노드는 최대 M - 1개의 키를 가질 수 있다.
- 각 노드는 최소 M/2개의 자식 노드를 가진다. (단, 루트 노드와 리프 노드는 제외)
  - 각 노드는 최소 M/2 - 1개의 키를 가진다. (루트 노드 제외)
- 모든 리프 노드들은 항상 같은 레벨에 위치한다.
- 각 노드는 key와 data로 이루어져있다.
  - 각 노드는 최대 M - 1개의 key를 가질 수 있다.
    - ex) 3차 B트리라면 최대 2개의 키를 가진다.
- key는 중복이 없으며 항상 정렬되어 있다. (중위 순회를 해보면 키가 정렬되어 있음)
- 각 노드는 자식 노드를 참조하는 포인터를 갖고 있다.

<br>

### 2) 탐색

> B-Tree의 탐색은 왜 빠른가?

B-Tree의 장점으로는 탐색에 있어 '균일성'을 얻을 수 있다. 거의 대부분의 탐색에서 O(logN)을 보장한다.

그러나 B-Tree에 갱신 작업(INSERT, UPDATE, DELETE)가 반복적으로 일어나게 되면, 어느 정도 처음에는 균형을 유지하려고 하지만 결국에는 균형이 일부 깨질 수밖에 없고 성능이 저하된다.

그래서 탐색 실패에 따른 풀 스캔 시에는 모든 노드를 다 탐색해야 하므로 O(N)보다 큰 시간이 소요되는 것이다.

- 백트랙킹으로 트리를 모두 탐색하려면 시간이 오래 걸릴 수 밖에 없다.

따라서 갱신 빈도가 높은 테이블에 작성되는 인덱스의 경우, 인덱스 재구성을 통해서 트리의 균형을 되찾는 작업이 필요하다.

<br>

### 3) 삽입

삽입 연산은 기본적으로 리프 노드에 삽입한다.

- 해당 노드가 들어갈 리프 노드 위치를 찾아서 적절한 곳에 배치한다.
- 단, 노드가 넘치면 가운데 키를 기준으로 좌우 키들을 분할하고 가운데 키는 승진한다.
  - 노드가 넘친다? M차 B트리에서 각 노드들이 가질 수 있는 자식의 수는 M - 1개인데 데이터 삽입 과정에서 이러한 규칙을 위반한것을 말한다.

#### (1) 삽입 과정

1. 트리가 비어있다면 루트 노드를 할당하고 K를 삽입한다.
2. 트리가 비어있지 않다면, 데이터를 넣을 적절한 리프 노드를 탐색한다.
3. 리프 노드에 데이터를 넣고 리프 노드가 적절한 상태에 있다면 종료한다.
4. 리프 노드가 부적절한 상태에 있다면 분리한다.

#### (2) 분할이 일어나지 않는 경우

- 8삽입 시작, 10보다 작으니 왼쪽 서브 트리로 이동

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/1dc9f9cf-8a96-439c-9caa-a70157f0e5a2)

- 8은 5보다 크기 때문에 오른쪽 서브 트리로 이동

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/659d1b0b-0683-4b65-8e68-6a13ac132d35)

- 최종적으로 7옆에 삽입

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/a6601360-8b94-4b67-8848-bcf822b84304)

#### (3) 분할이 일어나는 경우

노드가 넘칠 경우 중간값의 키를 기준으로 분할한다. (반복)

|                              1                               |                              2                               |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/1af7b8e9-cada-4af8-bd75-ad2bc4052864) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ac65d85c-d08e-41fd-8616-0aac7a1c1621) |
|                            **3**                             |                            **4**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/00c65129-212b-4eff-9e91-9fe17188eb22) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/fd3936e3-1ed9-47d9-bf69-7448df432396) |
|                            **5**                             |                            **6**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/b89005b0-3829-4ba5-a9d2-78496c1cefe5) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/43eb3b34-c650-4d21-8156-6472a52d2792) |
|                            **7**                             |                            **8**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/c59cefa8-85eb-4b76-a386-04fcaba3a592) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ad33cb03-0381-4eb4-941c-8cd7b850a201) |
|                            **9**                             |                                                              |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/4d628069-dc0c-4033-9cbb-ae57b0c24cf9) |                                                              |

<br>

### 4) 삭제

삭제도 항상 리프 노드에서 삭제한다.

- 중간 노드에서 삭제가 발생한다면?  리프 노드에 있는 데이터와 위치를 바꾼 후에 삭제를 시작한다.
  - 어떤 리프 노드와 바꿀 것인가? 선임자 혹은 후임자를 찾는다.
    - 선임자(predecessor): 나보다 작은 데이터들 중 가장 큰 데이터
    - 후임자(successor): 나보다 큰 데이터들 중 가장 작은 데이터
- 삭제 후, 노드가 가지는 최소 키의 개수를 만족하지 못하면 재조정한다.
  - 각 노드는 최소 M/2 - 1개의 키를 가진다. (루트 노드 제외)
  - 재조정 시에는 키 수가 여유가 있는 형제 노드들의 지원을 받는다.
  - 이것이 불가능하면 부모로부터 지원을 받고 형제와 합친다. 
  - 이 과정을 반복한다.

#### (1) 재조정이 필요없는 경우

리프 노드를 하나만 삭제하고, 최소 키 조건도 만족하는 경우 삭제하고 끝이다.

#### (2) 삭제 후 재조정을 거쳐야 하는 경우

형제 혹은 부모로 부터 지원을 받아 재조정하고, 재조정이 필요없을 때까지 이를 반복한다.





<br>

## 2. B+Tree

B+Tree는 B-Tree의 확장된 개념으로 데이터의 효율적인 삽입/검색/삭제를 추구하는 자료 구조이다.

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/fa246e35-702e-4163-b5a3-0a433b3300bc)

### 1) 특징

- 데이터는 리프 노드에만 저장하고, 리프 노드들은 링크드 리스트로 연결되어 있다.
  - 리프 노드가 아닌 노드들에 실제 데이터를 저장하지 않고, 키값만 저장함으로써 저장 공간을 B-Tree에 비해 더 효율적으로 사용할 수 있다.
  - 이에 따라 트리의 depth도 낮아진다.
  - 풀 스캔 시에도 리프 노드들의 링크드 리스트만 탐색하면 되기 때문에 B-Tree에 비해 탐색 시간이 빠르다.
  - 단, 동시에 단점도 될 수 있는데 모든 정보가 리프 노드들에 있기 때문에 무조건 리프 노드로 이동한 다음에 탐색을 시작한다.
- 리프 노드들의 집합을 시퀀스 셋(sequence set), 그 외의 노드들의 집합을 인덱스 셋(index set)이라고 한다.
- 인덱스 셋에 있는 노드들은 자식 노드들로 향하는 포인터를 갖고 있으며, 키 값을 통해서 리프 노드를 향해 탐색하는 구조이기 때문에 키의 중복이 있을 수도 있다.

<br>

## 3. 비교 요약

B-Tree와 B+Tree의 비교 요약

| 항목          | B-Tree                                                     | B+Tree                                                   |
| ------------- | ---------------------------------------------------------- | -------------------------------------------------------- |
| 데이터 저장   | 모든 노드에 저장                                           | 리프 노드에만 저장                                       |
| key의 중복    | 키 중복 없음                                               | 키 중복 존재 가능                                        |
| Full Scan     | 모든 노드 탐색                                             | 리프 노드에서 선형 탐색                                  |
| 단일 검색     | 자주 접근하는 노드를 루트 노드 가깝게 배치 가능하므로 빠름 | 모든 데이터가 리프 노드에 있기 때문에 리프 노드까지 가함 |
| 높이          | 비교적 높음                                                | 비교적 낮음(키 중복이 가능하기 때문)                     |
| 링크드 리스트 | 없음                                                       | 있음(리프 노드)                                          |

