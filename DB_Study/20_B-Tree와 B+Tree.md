# 20_B-Tree와 B+Tree

> B; Balanced (균형 잡힌)

<br>

## 1. B-Tree

비 마이너스 트리라고 읽는 사람도 있지만 -는 하이픈(-)이다. 따라서 공식 명칭은 `비 트리(B Tree)`이다.

트리의 노드가 한쪽으로만 치우치지 않도록 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬하여 `균형 잡힌 상태(balanced)`를 유지한다.

### 1) 특징

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ae118f66-c86b-4cd1-9da0-3c250bbb696b)

- 자식을 최대 M개 가질 수 있는 B 트리를 M차 B트리라고 한다.
  - ex) 3차 B트리는 최대 3개의 자식을 가질 수 있다. (위 캡처가 3차 B트리)
  - 각 노드는 최대 M - 1개의 키를 가질 수 있다.
- 각 노드는 최소 M/2개의 자식 노드를 가진다. (단, 루트 노드와 리프 노드는 제외)
  - 각 노드는 최소 M/2 - 1개의 키를 가진다. (루트 노드 제외)
- 모든 리프 노드들은 항상 같은 레벨에 위치한다.
- 각 노드는 key와 data로 이루어져있다.
  - 각 노드는 최대 M - 1개의 key를 가질 수 있다.
    - ex) 3차 B트리라면 최대 2개의 키를 가진다.
- key는 중복이 없으며 항상 정렬되어 있다. (중위 순회를 해보면 키가 정렬되어 있음)
- 각 노드는 자식 노드를 참조하는 포인터를 갖고 있다.

<br>

### 2) 탐색

> B-Tree의 탐색은 왜 빠른가?

B-Tree의 장점으로는 탐색에 있어 '균일성'을 얻을 수 있다. 거의 대부분의 탐색에서 O(logN)을 보장한다.

그러나 B-Tree에 갱신 작업(INSERT, UPDATE, DELETE)가 반복적으로 일어나게 되면, 어느 정도 처음에는 균형을 유지하려고 하지만 결국에는 균형이 일부 깨질 수밖에 없고 성능이 저하된다.

그래서 탐색 실패에 따른 풀 스캔 시에는 모든 노드를 다 탐색해야 하므로 O(N)보다 큰 시간이 소요되는 것이다.

- 백트랙킹으로 트리를 모두 탐색하려면 시간이 오래 걸릴 수 밖에 없다.

따라서 갱신 빈도가 높은 테이블에 작성되는 인덱스의 경우, 인덱스 재구성을 통해서 트리의 균형을 되찾는 작업이 필요하다.

<br>

### 3) 삽입

삽입 연산은 기본적으로 리프 노드에 삽입한다.

- 해당 노드가 들어갈 리프 노드 위치를 찾아서 적절한 곳에 배치한다.
- 단, 노드가 넘치면 가운데 키를 기준으로 좌우 키들을 분할하고 가운데 키는 승진한다.
  - 노드가 넘친다? M차 B트리에서 각 노드들이 가질 수 있는 자식의 수는 M - 1개인데 데이터 삽입 과정에서 이러한 규칙을 위반한것을 말한다.

#### (1) 삽입 과정

1. 트리가 비어있다면 루트 노드를 할당하고 K를 삽입한다.
2. 트리가 비어있지 않다면, 데이터를 넣을 적절한 리프 노드를 탐색한다.
3. 리프 노드에 데이터를 넣고 리프 노드가 적절한 상태에 있다면 종료한다.
4. 리프 노드가 부적절한 상태에 있다면 분리한다.

#### (2) 분할이 일어나지 않는 경우

- 8삽입 시작, 10보다 작으니 왼쪽 서브 트리로 이동

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/1dc9f9cf-8a96-439c-9caa-a70157f0e5a2)

- 8은 5보다 크기 때문에 오른쪽 서브 트리로 이동

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/659d1b0b-0683-4b65-8e68-6a13ac132d35)

- 최종적으로 7옆에 삽입

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/a6601360-8b94-4b67-8848-bcf822b84304)

#### (3) 분할이 일어나는 경우

노드가 넘칠 경우 중간값의 키를 기준으로 분할한다. (반복)

|                              1                               |                              2                               |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/1af7b8e9-cada-4af8-bd75-ad2bc4052864) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ac65d85c-d08e-41fd-8616-0aac7a1c1621) |
|                            **3**                             |                            **4**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/00c65129-212b-4eff-9e91-9fe17188eb22) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/fd3936e3-1ed9-47d9-bf69-7448df432396) |
|                            **5**                             |                            **6**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/b89005b0-3829-4ba5-a9d2-78496c1cefe5) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/43eb3b34-c650-4d21-8156-6472a52d2792) |
|                            **7**                             |                            **8**                             |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/c59cefa8-85eb-4b76-a386-04fcaba3a592) | ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/ad33cb03-0381-4eb4-941c-8cd7b850a201) |
|                            **9**                             |                                                              |
| ![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/4d628069-dc0c-4033-9cbb-ae57b0c24cf9) |                                                              |

<br>

### 4) 삭제

삭제도 항상 리프 노드에서 삭제한다.

- 중간 노드에서 삭제가 발생한다면?  리프 노드에 있는 데이터와 위치를 바꾼 후에 삭제를 시작한다.
  - 어떤 리프 노드와 바꿀 것인가? 선임자 혹은 후임자를 찾는다.
    - 선임자(predecessor): 나보다 작은 데이터들 중 가장 큰 데이터
    - 후임자(successor): 나보다 큰 데이터들 중 가장 작은 데이터
- 삭제 후, 노드가 가지는 최소 키의 개수를 만족하지 못하면 재조정한다.
  - 각 노드는 최소 M/2 - 1개의 키를 가진다. (루트 노드 제외)
  - 재조정 시에는 키 수가 여유가 있는 형제 노드들의 지원을 받는다.
  - 이것이 불가능하면 부모로부터 지원을 받고 형제와 합친다. 
  - 이 과정을 반복한다.

#### (1) 재조정이 필요없는 경우

리프 노드를 하나만 삭제하고, 최소 키 조건도 만족하는 경우 삭제하고 끝이다.

#### (2) 삭제 후 재조정을 거쳐야 하는 경우

형제 혹은 부모로 부터 지원을 받아 재조정하고, 재조정이 필요없을 때까지 이를 반복한다.

<br>

## 2. B+Tree

B+Tree는 B-Tree의 확장된 개념으로 데이터의 효율적인 삽입/검색/삭제를 추구하는 자료 구조이다.

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/fa246e35-702e-4163-b5a3-0a433b3300bc)

<br>

### 1) 특징

- 데이터는 리프 노드에만 저장하고, 리프 노드들은 링크드 리스트로 연결되어 있다.
  - 리프 노드가 아닌 노드들에 실제 데이터를 저장하지 않고, 키값만 저장함으로써 저장 공간을 B-Tree에 비해 더 효율적으로 사용할 수 있다.
  - 이에 따라 트리의 depth도 낮아진다.
  - 풀 스캔 시에도 리프 노드들의 링크드 리스트만 탐색하면 되기 때문에 B-Tree에 비해 탐색 시간이 빠르다.
  - 단, 동시에 단점도 될 수 있는데 모든 정보가 리프 노드들에 있기 때문에 무조건 리프 노드로 이동한 다음에 탐색을 시작한다.
    - 리프 노드들의 집합을 `시퀀스 셋(sequence set)`, 그 외의 노드들의 집합을 `인덱스 셋(index set)`이라고 한다.
- 인덱스 셋에 있는 노드들은 자식 노드들로 향하는 포인터를 갖고 있으며, 키 값을 통해서 리프 노드를 향해 탐색하는 구조이기 때문에 키의 중복이 있을 수도 있다.

<br>

### 2) 삽입 / 삭제

삽입/삭제 역시 B-Tree와 기본적으로 원칙이 같다.

다만, 리프 노드에만 데이터가 있기 때문에 재조정이 필요할 경우 데이터는 그대로 리프 노드에 남는다. 재조정되는 것은 key뿐이며, 그래서 key값에 중복이 존재하게 되는 것이다.

<br>

### 3) DB 인덱스로서 사용

B-Tree를 DB 인덱스에 사용해도 되지만 B+Tree가 DB 인덱스로 사용되었을 때 이점이 더 많다.

- 리프 노드에만 데이터를 담아두기 때문에, 나머지 노드들에 더 많은 key를 저장할 수 있다.
- 그래서 데이터 개수가 동일할 때, 더 많은 key를 저장할 수 있기 때문에 트리의 높이는 낮아진다.
- 이를 통해 캐시 히트(cached hit)를 높일 수 있을 뿐만 아니라, 범위 검색이나 범위 쿼리에도 큰 강점이 생긴다.
- DB 쿼리는 하나의 결과값만 리턴하는 경우만 있는 것이 아니라 여러 범위의 결과를 반환해야 하는 경우도 있다.
- 따라서 풀 스캔이 필요할 때도 있는데 B-Tree는 백트랙킹을 통해 모든 노드를 순회해야 하지만 B+Tree는 리프 노드만 선형 순회하면 된다.

<br>

## 3. 비교 요약

B-Tree와 B+Tree의 비교 요약

| 항목          | B-Tree                                                     | B+Tree                                                   |
| ------------- | ---------------------------------------------------------- | -------------------------------------------------------- |
| 데이터 저장   | 모든 노드에 저장                                           | 리프 노드에만 저장                                       |
| key의 중복    | 키 중복 없음                                               | 키 중복 존재 가능                                        |
| Full Scan     | 모든 노드 탐색                                             | 리프 노드에서 선형 탐색                                  |
| 단일 검색     | 자주 접근하는 노드를 루트 노드 가깝게 배치 가능하므로 빠름 | 모든 데이터가 리프 노드에 있기 때문에 리프 노드까지 가함 |
| 높이          | 비교적 높음                                                | 비교적 낮음(키 중복이 가능하기 때문)                     |
| 링크드 리스트 | 없음                                                       | 있음(리프 노드)                                          |

<br>

## 4. DB는 왜 B Tree를 선택하였는가?

> DB가 B-Tree 종류를 인덱스로 선택한 이유

### 1) 해시 테이블(Hash Table) ?

해시 테이블의 조회 성능은 O(1)로 B-Tree의 O(logN)보다 성능이 좋다.

그럼에도 불구하고 왜 해시 테이블을 DB 인덱스로 택하지 않았을까?

답은 간단하다. 해시 테이블의 성능은 `단 하나의 데이터를 탐색하는데 걸리는 시간`이다.

`우리는 DB에서 등호(=)뿐만 아니라 LIKE(%), 부등호(>, <)와 같은 기호를 사용하여 범위 검색`을 하기도 한다.

따라서 경우에 따라 조건에 일치하는 모든 데이터를 찾기 위해서는 정확히 하나의 데이터만 찾는 해시 테이블은 부적절할 수밖에 없다. 범위 검색 시 O(1)을 보장할 수도 없고 매우 비효율적이다.

<br>

### 2) 레드-블랙 트리(Red-Black Tree) ?

레드-블랙 트리는 SBBST(Selft Balancing Binary Search Tree, 자가 균형 탐색 트리) 중 하나로써 탐색에 걸리는 시간 복잡도는 B-Tree와 같이 O(logN)이다.

그럼에도 불구하고 레드-블랙 트리가 DB 인덱스의 자료 구조로 택하지 못한 이유는 다음과 같다.

레드-블랙 트리는 하나의 노드에 하나의 데이터만 들어가 있는 반면, B-Tree의 경우 하나의 노드에 최대 여러 개의 데이터가 들어갈 수도 있다.

탐색에 걸리는 시간 복잡도 둘 다 같지만, 이는 이론적인 시간 복잡도일 뿐. 레드-블랙 트리에서는 노드 수가 B-Tree보다 더 많기 때문에 그만큼 포인터도 더 많고 `데이터를 찾기 위해 연산 및 접근 횟수가 더 늘어난다.`

데이터가 작으면 상관없겠지만, 이미 인덱스를 쓰는 수준에서는 데이터 양이 많기 때문에 사용하는 것이기 때문에 성능적으로 더 유리한 B-Tree를 택한 것이다.

<br>

### 3) 배열(Array) ?

배열은 참조 포인터라는 게 없고, 메모리에 순차적으로 저장되어 있기 때문에 접근이 빠르다.

그렇다면 배열은 왜 DB 인덱스로 채택되지 않았을까?

`배열이 B-Tree보다 빠른 것은 탐색뿐`이다. 데이터의 삽입(저장), 삭제가 일어나는 순간부터는 B-Tree보다 훨씬 비효율적인 성능을 보여준다.

삽입, 삭제 연산이 발생할 때마다 O(N)이 소요되며, 여기에 매번 정렬까지 한다면 O(NlogN)이다.

<br>

### 4) 링크드 리스트(Linked List) ?

배열의 삽입, 삭제가 느리다면 선형 자료 구조이면서 삽입과 삭제가 빠른 링크드 리스트를 쓰면 되지 않을까?

그러나 안타깝게도 링크드 리스트는 `특정 데이터에 대한 랜덤 Access를 허용하지 않는다.`

즉, 찾고자 하는 데이터를 찾을 때까지 순차 탐색해야 하기 때문에 탐색에 있어서 B-Tree보다 비효율적이다.

#### (1) B+Tree는 링크드 리스트로 이뤄진 리프 노드에서 데이터 탐색을 하는데요?

맞다. B+Tree에 실제 데이터를 갖고 있는 것은 리프 노드들뿐이며, 링크드 리스트로 이루어져있다.

그런데 왜 일반적인 링크드 리스트보다 빠를까?

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/b657c5e3-d016-4b49-a295-e661f9c5cb9e)

그 이유는 key에 있다. B+Tree는 데이터 탐색 전 key를 통해서 불필요한 탐색을 줄이고 원하는 데이터와 가장 가까운 곳을 찾아서 탐색을 시작할 수 있다.





