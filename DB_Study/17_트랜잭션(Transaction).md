# 17_트랜잭션(Transaction)

> 데이터베이스의 상태를 바꾸는 작업 단위

<br>

## 1. 개념

더이상 분할이 불가능한 작업 처리 `단위`를 의미한다.

- 단위라고 해서 제일 작은 수준이라고 보면 안 된다. `덩어리`라는 표현이 더 맞다.
- 단, 여기서 더이상 분할이 불가능하다는 의미는 절대 분리되어서는 안 되는 수준을 의미한다.
  - 예를 들어 `계좌 이체`를 보면 `A의 계좌에서 B의 계좌로 금액의 이동`이 발생하는 행위이다.
  - 이때, `A의 계좌에서 OO원을 인출`하고 `B의 계좌로 OO원을 입금`하는 과정이 분리되어서는 안 된다.
  - 왜냐하면 `인출은 성공했는데, 입금이 실패한다면 치명적인 결과`가 나온다.
  - 즉 계좌 이체에서 인출과 입금은 `둘 다 성공하던지, 둘 다 실패하던지 해야 한다.` (Atomic)

즉, 더이상 분할이 불가능한 작업 처리 단위를 묶은 것을 `트랜잭션(Transaction)`이라고 하며 데이터 거래에 있어 안전성을 확보하기 위한 방법이다.

사실 MySQL에서 우리가 사용한 일반적인 쿼리문들도 내부적으로는 Commit을 실행하여 반영되는 것이기 때문에 트랜잭션이라고 볼 수 있다. 

※ 그러나 상기했듯이, `작업의 단위`는 절대 쿼리문 하나에 국한되는 것이 아니다. 여러 쿼리문의 집합이 작업의 단위가 될 수 있다.

### 1) 왜 사용할까?

> 데이터 거래의 안전성을 확보하기 위해

트랜잭션은 단순히 작업들을 한 번에 처리하기 위한 개념이 아니다. 여러 작은 작업들이 서로 연관성이 깊어 집합처럼 하나의 작업 단위로서 함께 처리되어야 할 때, 이 작업들을 개별적으로 적용하다가 문제가 생겨서 데이터의 `무결성, 신뢰성`에 문제가 생기는 것을 방지하고 데이터 거래의 `안전성`을 확보하기 위해서 사용한다.

<br>

### 2) 번외

#### (1) 읽기에는 트랜잭션을 걸지 않아도 될까?

조회, 읽기는 데이터의 변경을 동반하지 않기 때문에 일반적으로는 트랜잭션을 걸 필요 없으나, `필요할 때도 있다.`

- 읽기 결과의 일관성을 유지하기 위해 사용
  - 다른 트랜잭션이 수정 중일 때, 조회 작업이 발생하면 수정 전의 데이터를 읽을 수도 있기 때문에 읽기 결과에 일관성이 없어진다.
  - 따라서 조회 결과에도 일관성을 가져오기 위해 사용한다.

<br>

## 2. 특징 (ACID)

> 트랜잭션의 4가지 특징 ACID

### 1) 원자성(**A**tomicity)

트랜잭션의 결과는 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다.

"All Or Nothing"

<br>

### 2) 일관성(**C**onsistency)

트랜잭션 작업 처리의 결과는 항상 일관성이 있어야 한다.

시스템이 가지고 있어야 할 고정 요소는 트랜잭션 수행 전과 수행 후가 같아야 한다는 의미로, 트랜잭션 수행 도중 데이터베이스가 업데이트 된다고 하더라도, 업데이트된 데이터베이스에 트랜잭션이 진행되는 것이 아니라 처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스에 대해 트랜잭션이 수행된다.

<br>

### 3) 독립성(**I**solation)

동시에 트랜잭션이 수행되더라도, 어느 한 트랜잭션이 다른 트랜잭션에 영향을 미치지 않는다.

격리성이라고도 한다.

어느 한 트랜잭션이 다른 트랜잭션의 연산에 끼어들어서는 안 되며, 하나의 특정 트랜잭션이 완료될 때까지 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

<br>

### 4) 영구성(**D**urability)

트랜잭션이 성공적이었을 경우에 해당 트랜잭션의 결과는 영구적으로 반영되어야 한다.

<br>

## 3. 트랜잭션 상태

트랜잭션 연산은 다음과 같은 상태를 가지고 있다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/2f589313-d753-4363-b5b8-0ca56c9f094b)

### 1) 활성

트랜잭션이 정상 실행 중인 상태

트랜잭션이 실행되면 해당 트랜잭션의 상태는 활성(Active) 상태가 되며, 현재까지는 설계자가 의도한 대로 연산들이 정상 실행 중이라는 의미를 가지고 있다.

<br>

### 2) 부분 완료 및 완료

작업 성공 시 부분 완료 및 완료 상태가 된다.

#### (1) 부분 완료

트랜잭션의 마지막까지 성공되었지만 아직 Commit되기 전 상태

단, 부분 완료 상태이더라도 트랜잭션의 결과가 반영된 것이 아니다. 갑자기 중단된 후 롤백될 수 있기 때문에 Commit 연산이 완료되기까지는 완벽하게 완료되었다고 할 수 없다. 

#### (2) 완료

트랜잭션이 성공적으로 Commit까지 완료되어 종료된 상태

데이터베이스에 트랜잭션의 결과가 반영된 상태를 의미한다.

<br>

### 3) 실패 및 철회

#### (1) 실패

트랜잭션 실행에 오류가 있거나, 중단이 필요하여 중단된 상태

#### (2) 철회

트랜잭션이 비정상적으로 종료되어 `롤백(Rollback)` 연산을 수행하여 트랜잭션 수행 이전의 상태로 되돌아간 상태

<br>

## 4. 트랜잭션 사용

### 1) 트랜잭션 작성

```SQL
START TRANSACTION
 -- 쿼리문들 작성
 쿼리 A;
 쿼리 B;
COMMIT -- 혹은 ROLLBACK
```

<br>

### 2) 트랜잭션 작성 예시

계좌 이체 트랜잭션 작성 예시

#### (1) 테이블 생성

```SQL
-- 계좌 테이블
CREATE TABLE account (
    id     INT AUTO_INCREMENT PRIMARY KEY,
    name   VARCHAR (50)    NOT NULL,
    amount DECIMAL (19, 4) NOT NULL
);

-- 이체 기록 테이블
CREATE TABLE transferhistory (
    id         INT AUTO_INCREMENT PRIMARY KEY,
    from_id    INT    NOT NULL,
    to_id      INT    NOT NULL,
    amount     DECIMAL (19, 4) NOT NULL,
    transfer_date DATETIME 
);

-- 기본 데이터 삽입 
INSERT INTO account(name,amount)
VALUES('철수',1000000), ('영희',90000);
```

<br>

#### (2) 트랜잭션 작성

```SQL
-- 계좌 이체 트랜잭션 작성
START TRANSACTION;

-- 철수의 잔액에 - 500000 
update account
     set  amount = amount - 500000
 where id = 1 ;

-- 영희의 잔액에 + 500000 
update account
     set  amount = amount + 500000
 where id = 2 ;

INSERT INTO TransferHistory (from_id, to_id, amount, trans_date)
VALUES(1, 2, 500000, now());

COMMIT; -- 트랜잭션 반영

-- 반영 결과 조회
select * from account;
select * from transferhistory;
```

<br>

## 5. 트랜잭션 이상 현상

트랜잭션의 격리성(isolation)이 보장되지 않았을 때 발생할 수 있는 이상 현상들.

처리하는 트랜잭션과 관련된 주제가 금융, 재고와 같은 경우라면 트랜잭션 이상 현상으로 인해 발생하는 영향력은 어마어마하다.

### 1) Dirty Read

어떤 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 그것을 볼 수 있는 현상

- 예) 트랜잭션 A가 사용자의 키를 170에서 185로 변경한 내용이 아직 커밋되지 않았음에도 불구하고 트랜잭션 B가 사용자의 키를 조회했을 때 185로 조회하는 현상

#### (1) 문제가 되는 상황?

트랜잭션 A가 변경한 내용이 만약 롤백된다면, 트랜잭션 B는 결국에는 잘못된 결과를 commit하게 될 수도 있다.

<br>

### 2) Non-Repeatable Read (Fuzzy Read)

트랜잭션 내에서 동일한 SELECT 쿼리를 수행했을 때 항상 같은 결과를 보장해야 한다는 원칙에 위배되는 현상

- 예) 트랜잭션 A가 처음 사용자의 키에 대해서 조회했을 때는 170이지만, 트랜잭션 B가 같은 사용자의 키(=170)를 조회하고 이를 185로 바꾼 다음에 commit하고 종료되었을 때, 트랜잭션 A가 아직 수행 중인 상태에서 다시 동일한 사용자에 대한 키를 조회했을 때 170이 아니라 185로 조회를 함.

#### (1) 문제가 되는 상황?

트랜잭션 A가 단순히 조회만 한다면 같은 트랜잭션 내에서 잘못 조회가 됐을 때 영향도 자체는 조금 적을 수도 있다.

하지만 트랜잭션 A의 작업 단위가 조회 → 작업1 → 조회 → 작업2인데, 작업2가 조회 결과에 따라 영향을 받을 수 있다면? 전체 트랜잭션 작업 자체에 영향을 끼치게 된다.

<br>

### 3) Phantom Read

한 트랜잭션에서 동일한 쿼리를 수행했을 때, 처음 쿼리에서 존재하지 않던 유령(Phantom) 쿼리가 두 번째 쿼리를 수행했을 때 나타나는 현상.

다른 트랜잭션이 수행한 변경 작업에 의해 레코드가 보이지 않았다가 보이는 현상.

- 예) 트랜잭션 A가 금액 5천원 이상의 물건을 조회했을 때, 3개가 조회되었으나 트랜잭션 B가 금액 7천원짜리의 재고를 1증가시키면 트랜잭션 A가 동일한 트랜잭션 내에서 다시 금액 5천원 이상의 물건이 몇 개인지 조회했을 때는 4개가 나옴.

####  (1) 문제가 되는 상황?

트랜잭션 A가 점수 N점 이상의 사용자를 찾고(조회1), 검색된 사용자들에게 경품을 지급하는 작업1을 수행하고 있을 때, 트랜잭션 B가 갑자기 점수 N + 1의 사용자를 1명 더 추가한 다음 commit하면, 트랜잭션 A가 경품을 받은 사용자를 보고하기 위해 N점 이상의 사용자를 찾았을 때 그 결과가 달라짐.

- 트랜잭션 내에서 다른 조회 쿼리를 날리면 되지 않나요? 그렇지 못할 수도 있음

<br>

### 4) 트랜잭션의 격리성 수준

![image](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/a6a358c2-729b-40d9-8927-1f21aa9c36ba)

#### (1) Read Uncommited

- 커밋되지 않은 작업도 읽기 가능
- 데이터 무결성을 생각하면 안 하는게 좋은 격리 수준

#### (2) Read Commited

- 커밋된 작업만 조회 가능
- 단, 커밋된 작업만 조회가 가능하기 때문에 두 트랜잭션이 커밋된 작업을 조회했더라도 다른 트랜잭션이 수정은 할 수 있다.
- 가장 많이 사용되는 격리 수준

#### (3) Repeatable Read

- 한 트랜잭션이 수행한 행을 다른 트랜잭션이 수정하는 작업을 할 수 없도록 막는 격리성 수준
- Inno DB 스토리지 엔진에서 기본적으로 사용
- 한 트랜잭션 내에서 동일한 조회 쿼리에 대해 항상 똑같은 조회 결과를 보여줌

#### (4) Serializable

- 가장 엄격한 수준의 격리성
- 트랜잭션을 순차적으로 진행하기 때문에 동시성이 매우 떨어진다.
- 다른 트랜잭션이 접근하지 못하도록 락을 걸기도 한다.
- 만약에 서로 락을 건다면 교착 상태가 발생할 수도 있어 성능이 매우 떨어지게 된다.
