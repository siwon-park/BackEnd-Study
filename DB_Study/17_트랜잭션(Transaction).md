# 17_트랜잭션(Transaction)

> 데이터베이스의 상태를 바꾸는 작업 단위

<br>

## 1. 개념

더이상 분할이 불가능한 작업 처리 단위를 의미한다.

- 단, 여기서 더이상 분할이 불가능하다는 의미는 절대 분리되어서는 안 되는 수준을 의미한다.
  - 예를 들어 `계좌 이체`를 보면 `A의 계좌에서 B의 계좌로 금액의 이동`이 발생하는 행위이다.
  - 이때, `A의 계좌에서 OO원을 인출`하고 `B의 계좌로 OO원을 입금`하는 과정이 분리되어서는 안 된다.
  - 왜냐하면 `인출은 성공했는데, 입금이 실패한다면 치명적인 결과`가 나온다.
  - 즉 계좌 이체에서 인출과 입금은 `둘 다 성공하던지, 둘 다 실패하던지 해야 한다.` (Atomic)

즉, 더이상 분할이 불가능한 작업 처리 단위를 묶은 것을 `트랜잭션(Transaction)`이라고 하며 데이터 거래에 있어 안전성을 확보하기 위한 방법이다.

사실 MySQL에서 우리가 사용한 일반적인 쿼리문들도 내부적으로는 Commit을 실행하여 반영되는 것이기 때문에 트랜잭션이라고 볼 수 있다. 

※ 그러나 상기했듯이, `작업의 단위`는 절대 쿼리문 하나에 국한되는 것이 아니다. 여러 쿼리문의 집합이 작업의 단위가 될 수 있다.

### 1) 왜 사용할까?

> 데이터 거래의 안전성을 확보하기 위해

트랜잭션은 단순히 작업들을 한 번에 처리하기 위한 개념이 아니다. 여러 작은 작업들이 서로 연관성이 깊어 집합처럼 하나의 작업 단위로서 함께 처리되어야 할 때, 이 작업들을 개별적으로 적용하다가 문제가 생겨서 데이터의 `무결성, 신뢰성`에 문제가 생기는 것을 방지하고 데이터 거래의 `안전성`을 확보하기 위해서 사용한다.

<br>

### 2) 번외

#### (1) 읽기에는 트랜잭션을 걸지 않아도 될까?

조회, 읽기는 데이터의 변경을 동반하지 않기 때문에 일반적으로는 트랜잭션을 걸 필요 없으나, `필요할 때도 있다.`

- 읽기 결과의 일관성을 유지하기 위해 사용
  - 다른 트랜잭션이 수정 중일 때, 조회 작업이 발생하면 수정 전의 데이터를 읽을 수도 있기 때문에 읽기 결과에 일관성이 없어진다.
  - 따라서 조회 결과에도 일관성을 가져오기 위해 사용한다.

<br>

## 2. 특징 (ACID)

> 트랜잭션의 4가지 특징 ACID

### 1) 원자성(**A**tomicity)

트랜잭션의 결과는 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다.

<br>

### 2) 일관성(**C**onsistency)

트랜잭션 작업 처리의 결과는 항상 일관성이 있어야 한다.

시스템이 가지고 있어야 할 고정 요소는 트랜잭션 수행 전과 수행 후가 같아야 한다는 의미로, 트랜잭션 수행 도중 데이터베이스가 업데이트 된다고 하더라도, 업데이트된 데이터베이스에 트랜잭션이 진행되는 것이 아니라 처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스에 대해 트랜잭션이 수행된다.

<br>

### 3) 독립성(**I**solation)

동시에 트랜잭션이 수행되더라도, 어느 한 트랜잭션이 다른 트랜잭션에 영향을 미치지 않는다.

격리성이라고도 한다.

어느 한 트랜잭션이 다른 트랜잭션의 연산에 끼어들어서는 안 되며, 하나의 특정 트랜잭션이 완료될 때까지 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

<br>

### 4) 영구성(**D**urability)

트랜잭션이 성공적이었을 경우에 해당 트랜잭션의 결과는 영구적으로 반영되어야 한다.

<br>

## 3. 트랜잭션 상태

트랜잭션 연산은 다음과 같은 상태를 가지고 있다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/2f589313-d753-4363-b5b8-0ca56c9f094b)

### 1) 활성

트랜잭션이 정상 실행 중인 상태

트랜잭션이 실행되면 해당 트랜잭션의 상태는 활성(Active) 상태가 되며, 현재까지는 설계자가 의도한 대로 연산들이 정상 실행 중이라는 의미를 가지고 있다.

<br>

### 2) 부분 완료 및 완료

작업 성공 시 부분 완료 및 완료 상태가 된다.

#### (1) 부분 완료

트랜잭션의 마지막까지 성공되었지만 아직 Commit되기 전 상태

단, 부분 완료 상태이더라도 트랜잭션의 결과가 반영된 것이 아니다. 갑자기 중단된 후 롤백될 수 있기 때문에 Commit 연산이 완료되기까지는 완벽하게 완료되었다고 할 수 없다. 

#### (2) 완료

트랜잭션이 성공적으로 Commit까지 완료되어 종료된 상태

데이터베이스에 트랜잭션의 결과가 반영된 상태를 의미한다.

<br>

### 3) 실패 및 철회

#### (1) 실패

트랜잭션 실행에 오류가 있거나, 중단이 필요하여 중단된 상태

#### (2) 철회

트랜잭션이 비정상적으로 종료되어 `롤백(Rollback)` 연산을 수행하여 트랜잭션 수행 이전의 상태로 되돌아간 상태

<br>

## 4. 트랜잭션 사용

### 1) 트랜잭션 작성

```SQL
START TRANSACTION
 -- 쿼리문들 작성
 쿼리 A;
 쿼리 B;
COMMIT -- 혹은 ROLLBACK
```

<br>

### 2) 트랜잭션 작성 예시

계좌 이체 트랜잭션 작성 예시

#### (1) 테이블 생성

```SQL
-- 계좌 테이블
CREATE TABLE account (
    id     INT AUTO_INCREMENT PRIMARY KEY,
    name   VARCHAR (50)    NOT NULL,
    amount DECIMAL (19, 4) NOT NULL
);

-- 이체 기록 테이블
CREATE TABLE transferhistory (
    id         INT AUTO_INCREMENT PRIMARY KEY,
    from_id    INT    NOT NULL,
    to_id      INT    NOT NULL,
    amount     DECIMAL (19, 4) NOT NULL,
    transfer_date DATETIME 
);

-- 기본 데이터 삽입 
INSERT INTO account(name,amount)
VALUES('철수',1000000), ('영희',90000);
```

<br>

#### (2) 트랜잭션 작성

```SQL
-- 계좌 이체 트랜잭션 작성
START TRANSACTION;

-- 철수의 잔액에 - 500000 
update account
     set  amount = amount - 500000
 where id = 1 ;

-- 영희의 잔액에 + 500000 
update account
     set  amount = amount + 500000
 where id = 2 ;

INSERT INTO TransferHistory (from_id, to_id, amount, trans_date)
VALUES(1, 2, 500000, now());

COMMIT; -- 트랜잭션 반영

-- 반영 결과 조회
select * from account;
select * from transferhistory;
```





