# 13_테스트 코드 작성

## 01_테스트 코드와 필요성

### 테스트 코드

프로그래밍 코드를 사용해서 코드를 검증하는 것

### 테스트 코드의 필요성

#### 테스트 코드를 작성하지 않는다면?

- 기능A가 있을 때 해당 기능에서 파생된 기능이 여러 가지일 경우 모든 파생 기능에 대해 일일이 다 확인하기란 어렵다
- 최초 개발자가 기능을 개발하다가 다른 개발자가 이어 받아서 개발할 경우 테스트 코드가 없다면 버그 확률이 높아진다
  - 코드에 대한 이해가 완전히 안 된 상태에서 작업을 이어서 하니까 버그 발생 확률이 높아지는 것

#### 테스트 코드를 작성함으로써 얻는 이점

- 개발 과정에서 문제를 미리 발견할 수 있음
- 기능 추가와 리팩토링을 안전하게 할 수 있음
- 빠른 시간 내 코드의 동작 방식과 결과를 확인 가능
- 좋은 테스트 코드를 작성하려다 보면, 자연스럽게 좋은 코드가 만들어짐
- 잘 작성한 테스트는 문서 역할을 하기도 하며, 코드 리뷰를 돕기도 함

<br>

## 02_테스트 코드의 작성

### 테스트 코드의 작성

테스트 코드는 수동으로 작성할 수 있다. 그러나 수동으로 작성할 경우 다음과 같은 단점을 가진다.

- 테스트 클래스가 많아지며, 테스트 메서드를 개별적으로 실행하기가 어렵다.
- 테스트가 실패한 경우, 무엇을 기대하였고 어떤 잘못된 값이 들어와서 실패했는지 알 수 없다.
- 특정 케이스들에 대한 예외 처리 및 try / catch를 직접 사용해서 구현해야한다.
- 테스트 메서드별로 공통적으로 사용해야하는 기능에 대해, 중복으로 작성하게 된다.

이러한 단점들을 극복하기 위해 테스트 코드 작성을 도와주는 Junit이라는 테스트 프레임워크가 등장했다.

#### 큰 테스트 코드 1개보다 작은 테스트 코드를 여러 개 작성하는 것이 더 낫다

복잡한 테스트 코드 1개 보다, 간단한 테스트 코드 여러 개를 유지보수 하는 것이 더 쉽고 용이히다.

또한 테스트가 큰 단위로 합쳐지게 되면, 앞 부분에서 실패가 나는 경우, 뒷 부분은 아예 검증이 되지 않기 때문에 틀렸는지 맞았는지 모르게 된다.

| 테스트 메서드 1개                                            | 테스트 메서드 여러 개                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://user-images.githubusercontent.com/93081720/201507286-b3c5a9a1-62f0-45b1-b087-3168404f431d.png) | ![image](https://user-images.githubusercontent.com/93081720/201507319-29895235-e065-40b1-b569-f33a2c3b7ecc.png) |

<br>

## 03_Junit

Junit을 사용하면 메서드 단위로 테스트를 실행할 수도 있고, 클래스 단위로 테스트 메서드 전체를 실행할 수도 있다.

### Junit4

Springboot 2.1.x버전 이상부터는 자동적으로 Junit5가 적용되지만, 그 이전 버전의 Springboot의 경우 Junit은 4버전이다.

Junit4는 테스트 클래스 위에 `@RunWith(SpringRunner.class)`라는 어노테이션을 붙여줘야만 테스트를 진행할 수 있다.

또한 Junit4는 Junit5와 테스트를 검증하는 메서드의 이름이 조금 다르다.

### Junit5

Junit5에서 사용하는 필수 어노테이션들

#### @Test

해당 메서드를 테스트 메서드로 지정하는 어노테이션 

테스트 메서드는 실행하는 과정에서 오류가 없으면 테스트에 성공한 것이다.



#### @BeforeEach

각 테스트 메서드가 수행되기 전에 실행하는 메서드를 지정하는 어노테이션



#### @AfterEach

각 테스트가 수행된 후에 실행되는 메서드를 지정하는 어노테이션

테스트 코드를 분명히 개별적으로 실행했을 때는 통과했지만, 테스트 클래스 전체를 실행했을 때는 통과하지 못하는 경우가 있다.

예를 들어, 스프링부트 테스트 코드 작성 시, Service 계층의 경우 SpringContext에 의해 관리되는 계층이다. 해당 계층의 테스트를 테스트 클래스로 전체 실행할 경우, 이전 테스트 결과가 다음 테스트 결과에도 영향을 끼치게 된다.

- 예) 이전 테스트에 레포지토리에 저장했던 데이터가 다음 테스트를 진행할 때에도 여전히 남아있음

이 때, 이를 방지하기 위해 @AfterEach메서드를 사용해서 각 개별 테스트 메서드가 종료되었을 때, 데이터 삭제와 같이 실행해야 할 일들을 정해서 실행하게 하면 전체 테스트 클래스를 실행하더라도 테스트를 무사히 잘 통과할 수 있다.



#### @BeforeAll

모든 테스트를 수행하기 전에 최초 1회 수행되는 메서드를 지정하는 어노테이션

모든 테스트 메서드에 공통적으로 사용되는 내용을 해당 어노테이션과 함께 메서드로 지정하면 효과적이다.

※ 코틀린에서는 `@JvmStatic`어노테이션을 붙여줘야한다.



#### @AfterAll

모든 테스트를 수행한 후 최초 1회 수행되는 메서드를 지정하는 어노테이션

※ 코틀린에서는 `@JvmStatic`어노테이션을 붙여줘야한다.

![image](https://user-images.githubusercontent.com/93081720/200590165-acff659c-a613-4742-8650-109d1e52d670.png)

### Springboot에서의 테스트 코드 작성

![image](https://user-images.githubusercontent.com/93081720/200593166-8a7f3211-41c1-444e-83e3-46979d938d3b.png)

#### 각 계층별 테스트 진행 방법

|                            도메인                            |                      서비스/레포지토리                       |                           컨트롤러                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/93081720/200593276-7636f676-99f2-4054-8af7-ac28af5befd2.png) | ![image](https://user-images.githubusercontent.com/93081720/200593367-f2437fac-a726-47ff-955e-b0759b5085e5.png) | ![image](https://user-images.githubusercontent.com/93081720/200593436-a6968c1e-0fbe-4a07-bbd3-7015aefca244.png) |

#### 어떤 계층을 테스트해야하는가?

당연히 최상은 모든 계층에 대해서 많은 케이스에 대해 검증하는 것이나, 일반적인 상황에서는 보통 Service계층 테스트를 우선적으로 진행한다. 핵심 비즈니스 로직을 구현한 곳이 서비스 계층이기 때문에 데이터를 보냈을 때, 설계한 로직대로 잘 나오는지 테스트해볼 수 있기 때문이다.