# 32_Entity, DTO와 빌더 패턴

> Entity에 @Builder를 적용할 때 @NoArgsConstructor가 필요한데, DTO에는 필요하지 않은 이유?

엔티티는 프레임워크(JPA, Hibernate)가 객체를 리플렉션으로 생성하기 때문에 빈 생성자(@NoArgsConstructor)가 필수이고, DTO는 순수 POJO로 개발자가 직접 생성하기 때문에 무인 생성자가 반드시 필요하지 않기 때문.

- @AllArgsConstructor는 굳이 필요는 없지만, 빌더 패턴을 위해 편의성으로 붙임.
  - 여기서 말하는 편의성이란, new를 통해서 생성해야 하는 경우가 있을 때(테스트 용도로 객체를 마구 생성해야 할 때 등)의 편의성이며, 빌더 패턴만으로 객체를 만든다면 굳이 필요 없음(롬복이 자동 생성해주기 때문)
- 단, DTO의 경우 Jackson이나 ModelMapper 등을 통해 자동 맵핑/직렬화/역직렬화를 사용한다면 DTO에도 @NoArgsConstructor가 반드시 필요함. 

## 1. Entity의 경우

JPA/Hibernate는 데이터베이스에서 데이터를 읽어 엔티티 객체를 만들 때, 리플렉션(Reflection)을 사용하여 객체를 생성한다.

이 때, 리플렉션을 통해 객체 생성 시에는 반드시 기본 생성자(무인 생성자)가 있어야만 한다.

- 리플렉션의 `newInstance()`에서 반드시 파라미터가 없는 생성자가 필요하기 때문

### 1) 리플렉션(Reflection)

> 코드가 실행 중인 시점(런타임)에 클래스, 메서드, 필드 정보(메타 데이터)를 읽거나 조작할 수 있는 자바 기술

보통처럼 new로 객체를 직접 생성하는 것이 아니라, 해당 클래스(패키지명)을 아는 상태에서 이 클래스의 메타 데이터를 불러와서 객체를 생성하는 등의 행동을 할 수 있다.

```java
Class<?> clazz = Class.forName("com.example.User");
Object obj = clazz.getDeclaredConstructor().newInstance();
```

#### (1) 프레임워크는 클래스명을 어떻게 알까?

그럼 최소한 클래스명을 문자열로 알아야 한다는 제약이 생길텐데, 이거는 어떻게 처리할까?

프레임워크가 어노테이션(@Entity, @Component 등) 어노테이션이 붙은 클래스를 스캔(클래스패스(classpath) 전체를 스캔)하여 내부적으로 명단을 만든다.

또한 스프링 프레임워크의 경우 클래스를 빈으로 등록해야 하니, 클래스명을 사전에 스캔해야 한다.

이렇게 스캔한 클래스명을 가지고 있다가 런타임에 꺼내서 활용하는 것이다.

#### (2) 왜 리플렉션을 사용하는가?

개발자가 직접 생성하지 않고 프레임워크, 라이브러리가 알아서 작동하게 만들기 위한 장치.

#### (3) 언제 프레임워크가 강제로 만드는가?

(JPA) Repository를 통해 DB에서 데이터를 가져온 다음 객체를 생성할 때, 우리는 new 키워드를 사용하지 않는다. 바로 여기서 프레임워크/라이브러리가 알아서 리플렉션을 통해 객체를 생성하는 것이다.

```java
User user = userRepository.findById(1L).orElse(null); // new로 객체를 생성하지 않음
```

<br>

## 2. DTO의 경우

DTO의 경우 보통 프레임워크가 강제로 객체를 만드는 것이 아니라, 개발자가 직접 new를 통해 생성자를 호출하거나 빌더 패턴을 사용하여 직접 객체를 만든다.

따라서 리플렉션을 적용할 필요가 없으며, 기본 생성자가 없어도 빌더(@Builder)만 있으면 굳이 문제가 없다.

왜냐하면 롬복(Lombok)이 @Builder를 붙일 경우, 컴파일 시점에 @AllArgsConstructor를 자동으로 추가해주기 때문.

- 단, 만약에 직접 new를 통해 모든 필드가 있는 생성자를 생성하려 하는데 @AllArgsConstructor가 없다면 컴파일 에러가 발생한다.
- 직접 new로 생성하지 않고, 오로지 빌더 패턴만 사용하는 경우라면 굳이 @AllArgsConstructor를 붙일 필요는 없다.

### 1) 반드시 있어야 하는 경우

DTO에 @NoArgsConstructor를 반드시 붙여야 하는 경우도 있다.

Jackson이나 ModelMapper 등으로 직렬화/역직렬화를 하려고 할 때, 해당 라이브러리에서 리플렉션을 활용하기 때문에 반드시 @NoArgsConstructor가 필요하다. 붙이지 않아도 컴파일 에러는 발생하지 않지만, 직렬화/역직렬화를 제대로 하지 못해 런타임에 문제가 발생한다.

따라서 보통 DTO를 REST API의 응답으로 사용하거나 여러 계층 사이에서 Jackson, ModelMapper, MapStruct, Gson 등의 직렬화/역직렬화 도구를 사용한다면 꼭 @NoArgsConstructor를 추가해주는 것이 안정적이다.

