# 02_Spring Container



스프링 컨테이너는 

내 어플리케이션의 비즈니스 로직이 담긴 객체, 코드 (POJO)와

구성 메타 데이터(Configuration Metadata)를 조합하여 하나의 동작 가능한 어플리케이션으로 만들어준다.

이를 Bean이라는 것으로 구성하여 서버 어플리케이션 오브젝트로 만들어주는 것



스프링 컨테이너는 한 번 만든 오브젝트를 계속해서 사용한다. 딱 1번만 생성하고, 그 이후에는 다시 생성하지 않고 계속해서 사용함 => 싱글톤(Singleton)

(그러나 실제 싱글톤 패턴은 아니고, 마치 싱글톤처럼 동작하게 끔 보이는 것임)

- 서블릿 컨테이너의 서블릿이 요청을 하면 스프링 컨테이너는 해당 오브젝트를 매번 생성해서 리턴하는 것이 아니라, 이미 만들어져있는 1개의 오브젝트를 계속해서 리턴한다. (재사용)





### Dependency Injection (의존성 주입)

- Spring IoC / DI Container

스프링 컨테이너는 어떤 오브젝트 A가 다른 어떤 오브젝트 B의 사용이 필요할 때, A가 필요한 의존 오브젝트 B를 생성하여 의존성을 주입시켜주는 역할까지 한다.

Assembler 역할



예를 들어, HelloController가 있다고 치자.

HelloController가 SimpleHelloService를 호출해서 사용하고 있을 때, HelloController는 SimpleHelloController를 의존하고 있다고 한다. (직접 의존)

만약 여기서 SimpleHelloController가 아니라 ComplexHelloController로 변경이 필요하다고 할 때, HelloController에는 소스 코드 레벨에서 변경이 필요할 것이다. 또한 SimpleHelloController의 메서드가 변경되어도 HelloController는 영향을 받는다.

이를 해결하기 위해 HelloService라는 인터페이스를 만들고 이를 구현한 SimpleHelloController와 ComplexHelloController를 사용한다면 적어도 이제 더 이상 소스 코드 레벨에서는 변경이 필요 없을 것이다. 타입이 HelloService이기만 하면 이를 구현한 어떤 클래스를 불러와도 되기 때문이다.

하지만 소스 코드 레벨에선 변경이 필요없다 해도, HelloController는 HelloSerive를 구현한 어떤 클래스 오브젝트를 호출해서 사용해야 할지에 대해 알 수 없다.

이 작업을 해주는 과정이 Dependency Injection이라 하고, 이러한 DI 작업을 해주는 것이 Assembler이다.

외부에서 생성한 오브젝트를 다른 오브젝트에서 사용할 수 있도록 의존성을 주입해주는 것이다.

- 생성자를 통해 주입(의존성을 사용할 클래스 오브젝트를 생성할 때 파라미터로 받음)
- 팩토리 메서드로 빈을 생성하여 파라미터로 주입
- 의존성을 사용할 클래스 오브젝트의 프로퍼티에 해당 의존성 오브젝트를 정의하고, setter 메서드를 통해 호출하여 주입



### 디스패처 서블릿

지금까지 작성한 서블릿을 보면 서블릿에서 맵핑, 컨트롤러의 메서드 직접 호출 작업 결정, 파라미터 바인딩(==DTO에 필요한 내용들을 넣는 과정과 유사) 등의 작업을 직접 하고 있었음

이러한 작업을 대신 해주는 하나의 서블릿이 디스패처 서블릿이다.



디스패처 서블릿은 빈을 다 탐색해서 웹 요청을 처리할 수 있는 맵핑 정보를 갖고 있는 클래스를 찾아서 웹 요청을 처리할 수 있는 메서드들을 추출해서 테이블을 만들고, 이후 해당 요청을 올바른 곳으로 보낸다.

그러나 메서드 단위에서 `@GetMapping` 어노테이션을 달았다고 해서 디스패처 서블릿이 이를 인지할 수 있는 것은 아니다. 왜냐하면 메서드까지 전부 다 탐색하는 것은 매우 매우 비효율적이기 때문이다.

그래서 클래스 단위로 탐색을 하며, 클래스에 `@RequestMapping`이 있으면 이를 인지한다.

단, 디스패처 서블릿은 String Type으로 리턴하게 되면 해당 String값을 이름으로 가지는 뷰(View)를 찾아서 반환하기 때문에 해당 뷰가 없다면 에러(404)를 반환한다.

- 뷰는 jsp, thymeleaf 등과 같은 자바 서버 페이지이다.



팩토리 메서드

- 오브젝트를 생성하는 로직을 담고 있는 메서드
- `@Bean` => 빈 오브젝트를 생성하는 팩토리 메서드임을 명시
- `@Configuration` => @Bean 메서드가 있는 클래스임을 명시하는 것(구성 정보를 가진 클래스다)
  - 스프링 컨테이너가 이를 인식하여 빈 오브젝트를 생성함

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/7c0ca6fa-e9b1-456c-b261-ef1d42b59a25)



@Component

- 스프링 구성 요소로 인식하게 하는 어노테이션
- 장점) 손쉽게 어노테이션 등록으로 구성 정보를 등록 가능
- 단점) Component 클래스가 많이 만들어지면 정확히 어떤 클래스 요소가 Bean으로서 등록되는지 찾는게 번거로움 => 그래도 편리성이 커서 자주 사용함

@ComponentScan

- @Component라는 어노테이션이 붙은 스프링 구성요소를 스캔하여 해당 오브젝트가 스프링 빈 오브젝트로 사용되도록 함
- @Configuration과 함께 사용됨



메타 어노테이션

- 어노테이션 위에 붙은 어노테이션
- 왜 만드는가?
  - Bean 오브젝트가 구체적으로 어떤 오브젝트인지 명시하기 위해서 사용 (Component만으로는 무엇인지 알 수 없으니)
    - @Controller나 @RestController 역시 내부 코드를 확인하면 @Component가 내장된 메타 어노테이션이다. (@Controller와 같은 어노테이션을 스테레오 타입 어노테이션이라고 함)
      - @RestController의 경우 @Controller를 포함하고 있으며, @ResponseBody도 포함하고 있기 때문에 API로서 더 적합한 기능을 할 수 있음
        - @ResponseBody 때문에 응답으로 받는 오브젝트 자체로 본다

![image](https://github.com/siwon-park/BackEnd-Study/assets/93081720/07d15813-e608-4bf1-9836-61c191a11071)



오토와이어링

사용하는 오브젝트 구현체가 유일하다면, 자동으로 DI를 해주는 것

- 예를 들어 HelloController에서 HelloInterface를 생성자를 통해 주입받는데, 이를 구현하여 빈으로 등록된 구현체 오브젝트가 한 개라면, 자동으로 주입시켜준다.
- 하지만 HelloInterface를 구현한 오브젝트가 여러 개라면 스프링 프로젝트를 실행했을 때 에러가 발생함
  - 구현한 오브젝트는 여러 개인데 누구를 주입할지 모르기 때문



데코레이터 (프록시 패턴)

여러가지 책임을 대신 조금 더 주는 구현체



