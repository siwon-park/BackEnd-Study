# 34_스프링에서의 예외 처리

> 스프링에서 예외를 처리하는 방법들

## 1. 직접 예외를 잡거나 던지기

> catch 혹은 throw 하기

보통 일반적으로는 비즈니스 로직을 갖고 있는 Service 레이어에서 예외를 처리하거나 던지는 형태로 개발을 한다.

컨트롤러단에서 try-catch를 써도 되지만,

- 모든 컨트롤러에서 try-catch 중복 코드가 발생되며
- 예외 처리 로직이 레이어에 걸쳐 분산되어 유지보수가 어렵다는 단점이 있어

잘 사용하지 않는다.

그래서 보통 서비스 레이어에서 예외 잡아서 던지고, 컨트롤러는 단순히 서비스를 호출하는 방식으로 개발한다.

### 1) 컨트롤러에서는 예외를 처리하지 않는다?

컨트롤러에서는 서비스를 호출만 한다고 해서 아무것도 안 하고 예외를 던지기만 해도 될까? 그러나 이 방법에는 문제가 있다.

컨트롤러에서 예외를 잡지 않고 던지기만 하면 스프링에서는 자동으로 에러를 500 Internal Server Error로 프론트로 던진다.

그러면 프론트에서는 요청에 대한 응답으로 에러를 받았는데, 모든 에러에 대한 응답이 500이니 실제로는 잘못된 요청(400 Bad Request)이어도 무조건 서버쪽의 에러로 보이게 된다는 단점이 생긴다.

이렇게 되면 개발 시 디버깅을 하기 어려워질 수밖에 없다. 보통 에러 응답에 따라 문제 원인을 찾는데, 500 에러니 서버쪽에서 부터 원인을 찾으려고 한다.

### 2) 올바른 방식?

올바른 방식은 백엔드에서 예외를 핸들링(Exception Handling)하는 것이다.

서비스에서 예외를 잡아서 던지고, 컨트롤러는 서비스를 호출하기만 한다고 했는데 그러면 어떻게 예외를 핸들링해야 하는 걸까?

<br>

## 2. GlobalExceptionHandler

백엔드에서 예외를 핸들링하는 올바른 방식은 (글로벌) 예외 핸들러를 작성하는 것이다.

글로벌 예외 핸들러란 모든 예외를 한 곳에서 처리하기 위한 방법으로, 사용자 정의 예외를 정의한 다음 컨트롤러에서 던지는 그 예외를 종류에 맞게 잡아서 공통된 혹은 특정한 응답으로 리턴하는 방식으로 동작한다.

### 1) 계층별 책임

#### (1) 서비스 (Service)

"예외를 던지는 곳"

- 비즈니스 로직 / 규칙(검증) 구현
- 사용자 정의 예외 던지기 ✔

#### (2) 컨트롤러 (Controller)

"요청에 대한 응답"

- 서비스 호출하여 요청에 대한 응답을 반환
- 서비스 레이어에서 던진 예외는 직접 처리하지 않고 GlobalExceptionHandler에게 위임 ✔

#### (3) GlobalExceptionHandler

"전역 예외 처리"

- 모든 예외를 한 곳에서 처리 ✔
- (사용자 정의) 예외에 대한 일관된 에러 응답 반환

### 2) 사용자 정의 예외 정의

Java의 기본 예외를 잡아도 되지만, 사용자 정의(커스텀) 예외를 정의하여 어플리케이션의 에러를 핸들링하는 것이 더 올바른 방법이다.

```java
// 1) 사용자를 찾을 수 없을 때
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
    
    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 2) 중복된 사용자가 있을 때
public class DuplicateUserException extends RuntimeException {
    public DuplicateUserException(String message) {
        super(message);
    }
}

// 3) 잘못된 요청 데이터
public class InvalidRequestException extends RuntimeException {
    public InvalidRequestException(String message) {
        super(message);
    }
}
```

#### (1) @ResponseStatus

예외 클래스에 작성하는 어노테이션으로 사용자 정의 예외에 대한 HTTP 상태 코드를 정의하기 위해 작성한다.

즉, "사용자를 찾을 수 없는 예외"를 정의했을 때 이 예외에 대한 HTTP 상태 응답을 404 Not Found로 지정하는 것이다.

```java
@ResponseStatus(HttpStatus.NOT_FOUND) // UserNotFoundException 발생 시 응답 상태는 404
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
```

이 어노테이션을 지정할 경우 컨트롤러에서 예외를 던지면 미리 정의된 HTTP 상태 코드로 응답을 반환하니 좀 더 상세한 예외 처리가 가능해진다.

물론 GlobalExceptionHandler에서 예외를 처리할 때 ResponseEntity에서 정의해줘도 무방하다.

### 3) @ExceptionHandler

특정 컨트롤러에서만 혹은 GlobalExceptionHandler에서 특정 예외를 타겟으로 처리하기 위해 작성하는 어노테이션으로, 어노테이션 괄호 안에 있는 예외를 대상으로 한다는 의미를 지닌다.

```java
@ExceptionHandler(UserNotFoundException.class) // UserNotFoundException 예외를 처리할 예정
public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
    // ... 중략 ...
}
```

#### (1) 우선순위

@ExceptionHandler 사용 시 예외 처리는 가장 구체적인 것부터 처리함을 유의해야 한다.

즉, 만약에 UserNotFoundException 예외가 RuntimeException을 구현했을 경우 우선순위는 다음과 같으며,

```
1) UserNotFoundException → 2) RuntimeException → 3) Exception
```

GlobalExceptionHandler에서는 사용자 정의 예외를 먼저 처리하고 그 다음 RuntimeException, 최후의 수단으로 Exception을 처리하게 끔 작성하면 된다.

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 1순위: 가장 구체적
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handleUserNotFound(UserNotFoundException e) { ... }
    
    // 2순위: 더 일반적
    @ExceptionHandler(RuntimeException.class)
    public ErrorResponse handleRuntime(RuntimeException e) { ...  }
    
    // 3순위: 가장 일반적 (최후의 수단)
    @ExceptionHandler(Exception.class)
    public ErrorResponse handleGeneral(Exception e) { ... }
}
```

#### (2) 로컬 예외 처리 (특정 컨트롤러에서만 예외 처리)

@ExceptionHandler는 반드시 GlobalExceptionHandler에서만 사용하는 것이 아니라, 컨트롤러의 메서드에서도 사용 가능하다.

즉 특정 컨트롤러 한정으로 예외를 처리하고 싶다면, 해당 컨트롤러에서 @ExceptionHandler가 붙은 예외 처리용 메서드를 구현해주면 된다. 물론 어떤 예외를 처리할 것인지 타겟팅은 필수이다.

### 4) @ControllerAdvice / @RestControllerAdvice

GlobalExceptionHandler를 구현할 때, @ControllerAdvice나 @RestControllerAdvice를 붙여서 개발한다.

이 두 어노테이션의 차이는 @Controller와 @RestController의 차이라고 이해하면 편하다.

#### (1) @ControllerAdvice

- 명시적으로 ResponseEntity를 반환해줘야 한다.
- 뷰(view, jsp, thymeleaf 등)를 반환할 수도 있다.
- @ResponseBody를 붙여줘야만 json으로 직렬화할 수 있다.

#### (2) @RestControllerAdvice

- 자동으로 @ResponseBody가 적용되어 있어 반환 객체의 자동 json 직렬화가 가능하다. (객체만 반환해도 됨)
- REST API에 최적화 되어 있으며, 뷰를 반환하는 것은 불가능하다.
- 상태 코드 지정을 하지 않을 경우, 200 OK 응답으로 나간다는 단점이 있다.
  - 응답으로 직접 ResponseEntity를 반환하여 상태값을 직접 지정하거나, @ResponseStatus를 사용하여 메서드 레벨에서 상태를 정의할 수도 있다.

### 5) GlobalExceptionHandler 예시

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handleUserNotFound(UserNotFoundException e) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)  // 404 Not Found 지정
            .body(new ErrorResponse("NOT_FOUND", e.getMessage()));
    }
    
    @ExceptionHandler(DuplicateUserException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST) // @ResponseStatus로 400 Bad Request 지정
    public ErrorResponse handleDuplicateUser(DuplicateUserException e) {
        return new ErrorResponse("CONFLICT", e.getMessage());
    }
    
    @ExceptionHandler(RuntimeException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleRuntime(RuntimeException e) {
        return new ErrorResponse("RUNTIME_ERROR", e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGeneralException(Exception e) {
        return new ErrorResponse("INTERNAL_ERROR", e.getMessage());
    }
}
```

