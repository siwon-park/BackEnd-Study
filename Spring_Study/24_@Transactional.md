# 24_@Transactional

> @Transactional 어노테이션

어플리케이션 단에서 트랜잭션을 관리하기 위해서 사용하는 어노테이션

## 1. 트랜잭션(Transaction)

> 더 이상 쪼갤 수 없는 작업 처리 단위 (묶음)

작업 처리 단위이기 때문에 논리적으로 쪼갤 수 없다는 의미이지, 실제로 가장 작은 수준의 작업(량)이라고 오해하면 안 됨.

### 1) 사용 이유?

> 데이터 거래의 신뢰성, 무결성, 정합성, 안정성을 보장하기 위함

작업 진행 간에 데이터들의 변경과 교환이 발생하는데, 각 작업별로 개별적으로 데이터를 처리하다가 발생하는 문제(예 - 데이터 불일치) 를 방지하고 신뢰성과 안정성을 확보하기 위함에 목적이 있음.

단순히 작업을 한 번에 벌크(bulk)로 처리하는 것이 아님.

### 2) 특징(ACID)

- 원자성(Atomicity): 트랜잭션의 결과는 모두 반영 혹은 모두 반영되지 않아야 함(All or Nothing)
- 일관성(Consistency): 트랜잭션의 처리 결과는 항상 일관성이 있어야 함
- 독립성(Isolation): 트랜잭션의 수행은 독립적이어야 한다. 트랜잭션 수행 도중 한 트랜잭션이 다른 트랜잭션에 영향을 끼치면 안 됨
- 영구성(Durability): 트랜잭션의 결과는 영구적으로 반영되어야 함

<br>

## 2. @Transactional

>  어플리케이션 단에서 트랜잭션을 관리하기 위해서 사용하는 어노테이션

트랜잭션이라는 것을 보면, DB상에서 일어나는 쿼리 작업들의 집합이다.

즉 DBMS의 관점에 해당하는 요소인데, 어플리케이션에서 트랜잭션을 관리한다는 것은 무슨 의미인가?

### 1) Without Transaction

> 어플리케이션에서 트랜잭션을 관리하지 않는다면 무슨 일이 발생하는가?

#### (1) 작업 단위를 관리하지 않았을 때 발생할 문제들

예를 들어 다음과 같이, 프로젝트를 생성하는데 회사가 없으면 회사를 먼저 생성하고, 그 회사의 프로젝트로 등록하는 코드를 작성한다고 해보자.

![image](https://github.com/user-attachments/assets/520f6b11-228d-4008-b6bc-1ca2843bce99)

만약에 어플리케이션에서 트랜잭션을 관리하지 않으면 (회사가 없어서) 회사를 생성하는 것은 성공했는데 프로젝트 객체를 만드는 과정에서 예외가 발생하여 프로젝트를 저장하지 못했다면 회사의 프로젝트가 정상적으로 만들어지지 않는 현상이 발생한다.

다른 예로 게임판을 생성하는 로직과 게임 방을 생성하는 로직이 하나의 서비스 메서드로 묶여 있다고 할 때, 게임방을 먼저 만드는 작업은 성공했지만 그 후에 게임판을 만드는 작업이 실패한다면, 비어있는 게임방이 만들어지는 사태도 발생할 것이다.

![image](https://github.com/user-attachments/assets/d6ffaa58-8569-4251-a6c6-ee6e3bfa0a66)

결론적으로 서비스 로직이 정상적으로 동작하지 않아 어플리케이션이 정상적인 동작을 못하게 된다.

#### (2) DB 입장에서는 별개의 요청이다

DB는 들어오는 요청에 대한 처리를 할 뿐, 어플리케이션에 있는 로직들이 하나의 작업으로 이루어져야 함은 알 수 없다

![image](https://github.com/user-attachments/assets/0f3824b0-f1fc-445a-8b9e-333832175dde)

따라서 서비스 로직이 정상적으로 동작하려면 작업들이 전부 성공하거나 아예 실패해야하기 때문에 어플리케이션에서 작업을 단위로 묶어서 요청을 해야 한다.

### 2) With Transaction

어플리케이션에서 서비스의 로직들이 정상적으로 처리된 다음에 DB로 한 번에 반영 요청을 하면 이러한 문제는 해결된다. 

![image](https://github.com/user-attachments/assets/39028c20-b733-4d54-867b-2f11bb97a112)

#### (1) 프로그래밍 방식

try-catch 구문과 setAutoCommit(false), commit(), rollback() 등의 메서드들을 활용하여 직접 코딩을 통해 작업 단위를 하나로 묶을 수도 있다.

그러나 이러한 방식은

- 코드 작성 실수가 발생할 수 있음
- 전체적으로 중복된 내용의 코드가 많아짐
- 서비스 레이어에 비즈니스 로직 외에 관심사(롤백 처리 등)이 많이 포함된다
- 특정 기술 혹은 예외에 종속적인 코드가 된다.

스프링에서는 이러한 한계를 해결하기 위해 다음과 같은 개념을 도입하였다.

#### (2) 프록시 객체의 활용

스프링에서는 프록시 객체라는 개념을 도입하여 이 문제를 해결하고자 하였다.

![image](https://github.com/user-attachments/assets/a87f9f4a-84f9-4a57-8593-f947a45e0675)

타겟 오브젝트를 상속받은 프록시 객체를 통해서 프록시 객체가 대신 이러한 로직을 수행하도록 하였다.

프록시 객체는 타겟 오브젝트를 상속 받고 트랜잭션을 여는 코드를 선언하고 타겟 객체를 호출하여 수행하고자 했던 로직들을 수행한 다음 트랜잭션을 종료한다.

즉, 타겟 오브젝트를 상속 받은 다음 트랜잭션 처리 코드를 삽입하여 재정의한 메서드를 통해 프록시 객체가 작업을 대신 수행하는 것이다.

![image](https://github.com/user-attachments/assets/54d430f9-1966-440f-a8c7-d99c9960fb47)

실제 코드 상으로는 컨트롤러는 서비스를 주입받아 서비스(타켓 오브젝트)에 의존하고 있는 것처럼 보이지만 내부적으로는 프록시 객체를 의존하고 있다. 따라서 실제로는 서비스가 스프링 빈으로 등록되는 것이 아니라 서비스를 상속받은 프록시 객체가 스프링 빈으로서 등록되며, 타겟 오브젝트인 서비스를 상속받았기 때문에 다른 클래스에서 서비스 타입(부모 타입)으로 호출이 가능한 것이다.

이를 통해 트랜잭션 시작 → 타겟 메서드 실행 → 트랜잭션 종료와 같은 흐름이 가능해지며, 트랜잭션 처리라는 공통된 부분과 비즈니스 로직을 분리하여 개발자는 비즈니스 로직에만 집중할 수 있게 되었다.

#### (3) 선언적 트랜잭션 관리

결론적으로 @Transactional 어노테이션이 붙어 있으면 빈 생성 시 타겟 오브젝트를 직접 빈으로 등록하지 않고, 이를 상속한 프록시 객체가 스프링 빈으로 등록되는 것이다.

이러한 방식을 선언적 트랜잭션 관리라고 한다.

즉, 스프링에서는 @Transactional로 선언한 클래스 혹은 메서드에서 트랜잭션으로 묶은 메서드들이 예외없이 성공적으로 호출되었을 때만 이를 DB에 커밋 요청을 보낸다.
