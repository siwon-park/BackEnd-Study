# 99_일단 정리



## 0. JPA가 자동으로 중계 테이블을 생성할 때

### 1) @ManyToMany

다대다 관계일 때 JPA는 자동으로 중계 테이블을 생성한다.

```java
@Entity
public class Member {
    @ManyToMany //  member_team(혹은 team_member)와 같은 중계 테이블 자동 생성
    private List<Team> teams;
}
```

### 2) @OneToMany 단방향 + @JoinColumn이 없을 때

@OneToMany 단방향 + @JoinColumn이 없을 때는 JPA입장에서는 어디에 FK를 둘지 알 수 없기 때문에 중간 테이블을 자동으로 생성하여 연관 관계를 관리한다.

```java
@Entity
public class Parent {
    @OneToMany
    private List<Child> children;
}

@Entity
public class Child {
    // 아무 매핑 없음
}
```

#### (1) @ManyToOne 단방향 + @JoinColumn이 없을 때

@ManyToOne 단방향 + @JoinColumn이 없을 때는 Many쪽에 FK 칼럼을 만든다.

관계 주인이 항상 Many쪽이기 때문에 중간 테이블을 자동으로 생성하지 않는다.

#### (2) @OneToMany 단방향 (@JoinColumn 없음) 과 동작이 다른 이유

결론적으로 JPA 디자인 철학상 "@ManyToOne만 있어도 FK가 어디에 들어가야 할지 JPA가 무조건 명확히 알 수 있다"고 보기 때문.

- JPA에서는 주인(Owner)가 누구인지 정하는 것이 핵심이다.
  - 양방향 맵핑 관계일 때는 반드시 관계의 주인이 누구인지 정해줘야 한다.
  - 그런데 단방향 관계에서는 연관 관계 어노테이션이 있는 쪽을 기본적으로 관계의 주인으로 본다.
  - 여기서 @OneToMany의 경우 One이 연관 관계의 주인이지만 FK를 역방향으로 둘 수 없고, 반대편의 관계의 엔티티의 어떤 칼럼으로 One쪽을 지칭할지 모른다.
    - "내가 B라는 엔티티를 관리해"라고 했지만 정작 B 엔티티쪽에는 A엔티티에 관한 정보가 없다. (A엔티티의 어떤 칼럼을 볼지 모른다.)
    - FK를 Many쪽에 놓고 싶지만 어떤 칼럼으로 관계를 맺을지 알 수 없어서 자동으로 FK를 두게 할 수  없다. (즉, 상대방 테이블의 어떤 칼럼을 외래키로 삼을지 모르기 때문에 못하는 것임)
    - 그래서 중계 테이블을 생성하는 것이다.
  - 하지만 @ManyToOne의 경우 어노테이션을 쓴 Many쪽이 연관 관계 주인이고, FK를 둘 수 있기 때문에 자동으로 FK를 생성하는 것이다.
    - 즉, @ManyToOne 단방향 관계를 사용한다는 것 자체가 Many쪽인 자신에게 FK 칼럼을 만들겠다와 같은 의미를 지니고 있다.



## 1. @JoinColumn

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;
}

@Entity
public class User {
    @Id
    private Long id;
    private String name;
}
```

### 1) name

#### (1) @ManyToOne일 때

- 현재 엔티티의 테이블에 생성될 FK(외래키) 칼럼 이름.
  - 현재 엔티티(자신)의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인
  - 위 코드 예시에서 order 테이블에는 user_id라는 FK 칼럼이 생기게 됨.

- 만약 생략할 경우 기본값은 `{필드명}_{참조 테이블의 PK 칼럼명}`이 된다.
  - 필드명이 user이고, 참조 테이블의 pk 칼럼이 id이기 때문에 user_id가 된다.

#### (2) @OneToMany일 때

- 상대 엔티티의 테이블에 생성될 FK 칼럼 이름.
  - 상대 엔티티의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인은 상대방 엔티티(테이블)

#### (3) 결론

- 결론적으로 FK는 Many쪽에 생성된다고 이해하면 된다.

### 2) referencedColumnName

- 참조 대상 테이블의 어느 칼럼을 FK로 가져갈지 정하는 속성
- 위 코드 예시에서 user 테이블의 id 칼럼을 참조한다고 명시
- 만약 생략할 경우 기본값은 상대 엔티티의 `@Id`어노테이션이 붙은 칼럼 (pk 칼럼)이 된다.
  - @OneToMany 관계일 경우에는 referencedColumnName은 현재 엔티티의 PK를 참조하기 때문에 사용하지 않는다. (의미가 없음)
  - @ManyToOne 관계일 때는 referencedColumnName이 중요하다.

- 대부분의 경우 상대 엔티티의 PK를 FK로 사용하는 경우가 많아서 생략 가능하지만, PK가 아닌 다른 unique 칼럼을 참조하거나 복합키일 때 필요하다.

<br>

## 2. mappedBy

mappedBy는 양방향 연관관계에서 한쪽에서만 FK를 실제로 관리하고, 나머지 한쪽은 읽기 전용으로 만들기 위한 설정이다.

- 연관 관계의 주인이 아닌 쪽에 명시하는 것이 원칙이다.
  - 연관 관계의 주인이란 FK 칼럼이 필드로 존재하는 엔티티이다.
- 따라서 대부분의 경우 연관 관계의 주인은 Many쪽이고 One은 주인이 아니다.
  - @OneToMany(mappedBy=...)을 많이 사용한다.

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")  // "나는 주인 아님, Order.user 필드가 주인"이라는 의미
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")  // 이쪽이 주인 (FK 관리)
    private User user;
}
```

### 1) "FK를 관리한다"의 의미

"DB 테이블 상에서 FK 값을 INSERT/UPDATE할 권한이 누구에게 있는가"

FK를 관리한다 == 실제 FK 칼럼을 수정할 수 있다.

```java
// 연관관계 주인(Order)에서 설정 → DB에 반영됨 ✅
Order order = new Order();
order.setUser(user);  // order 테이블의 user_id 컬럼에 값 들어감
em.persist(order);

// 주인이 아닌 쪽(User)에서 설정 → DB에 반영 안 됨 ❌
User user = new User();
user.getOrders().add(order);  // 이것만으론 order.user_id가 안 바뀜 -> order가 바뀌어야 하는데 실제 persist하는 대상 객체는 user임
em.persist(user);
```

FK 칼럼은 물리적으로 한 테이블에만 존재하기 때문에 FK 칼럼이 있는 엔티티가 그 값을 관리하는 것이 더 자연스러움.

만약 양쪽에서 다 관리를 하면

- order.setUser(user_A)하고, user_B.getOrders().add(order)을 하게되면 order 입장에서 FK는 user_A인가 user_B인가? => 충돌이 발생하는 셈이다.

그래서 FK의 주인인 엔티티에서 FK를 관리하는 것이 자연스럽기 때문에 이렇게 설계한 것이다.



## 3. orphanRemoval ?