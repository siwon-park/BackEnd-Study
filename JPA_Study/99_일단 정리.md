# 99_일단 정리



## 0. JPA가 자동으로 중계 테이블을 생성할 때

### 1) @ManyToMany

다대다 관계일 때 JPA는 자동으로 중계 테이블을 생성한다.

```java
@Entity
public class Member {
    @ManyToMany //  member_team(혹은 team_member)와 같은 중계 테이블 자동 생성
    private List<Team> teams;
}
```

### 2) @OneToMany 단방향 + @JoinColumn이 없을 때

@OneToMany 단방향 + @JoinColumn이 없을 때는 JPA입장에서는 어디에 FK를 둘지 알 수 없기 때문에 중간 테이블을 자동으로 생성하여 연관 관계를 관리한다.

```java
@Entity
public class Parent {
    @OneToMany
    private List<Child> children;
}

@Entity
public class Child {
    // 아무 매핑 없음
}
```

#### (1) @ManyToOne 단방향 + @JoinColumn이 없을 때

@ManyToOne 단방향 + @JoinColumn이 없을 때는 Many쪽에 FK 칼럼을 만든다.

관계 주인이 항상 Many쪽이기 때문에 중간 테이블을 자동으로 생성하지 않는다.

#### (2) @OneToMany 단방향 (@JoinColumn 없음) 과 동작이 다른 이유

결론적으로 JPA 디자인 철학상 "@ManyToOne만 있어도 FK가 어디에 들어가야 할지 JPA가 무조건 명확히 알 수 있다"고 보기 때문.

- JPA에서는 주인(Owner)가 누구인지 정하는 것이 핵심이다.
  - 양방향 맵핑 관계일 때는 반드시 관계의 주인이 누구인지 정해줘야 한다.
  - 그런데 단방향 관계에서는 연관 관계 어노테이션이 있는 쪽을 기본적으로 관계의 주인으로 본다.
  - 여기서 @OneToMany의 경우 One이 연관 관계의 주인이지만 FK를 역방향으로 둘 수 없고, 반대편의 관계의 엔티티의 어떤 칼럼으로 One쪽을 지칭할지 모른다.
    - "내가 B라는 엔티티를 관리해"라고 했지만 정작 B 엔티티쪽에는 A엔티티에 관한 정보가 없다. (A엔티티의 어떤 칼럼을 볼지 모른다.)
    - FK를 Many쪽에 놓고 싶지만 어떤 칼럼으로 관계를 맺을지 알 수 없어서 자동으로 FK를 두게 할 수  없다. (즉, 상대방 테이블의 어떤 칼럼을 외래키로 삼을지 모르기 때문에 못하는 것임)
    - 그래서 중계 테이블을 생성하는 것이다.
  - 하지만 @ManyToOne의 경우 어노테이션을 쓴 Many쪽이 연관 관계 주인이고, FK를 둘 수 있기 때문에 자동으로 FK를 생성하는 것이다.
    - 즉, @ManyToOne 단방향 관계를 사용한다는 것 자체가 Many쪽인 자신에게 FK 칼럼을 만들겠다와 같은 의미를 지니고 있다.

<br>

## 1. @JoinColumn

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;
}

@Entity
public class User {
    @Id
    private Long id;
    private String name;
}
```

### 1) name

#### (1) @ManyToOne일 때

- 현재 엔티티의 테이블에 생성될 FK(외래키) 칼럼 이름.
  - 현재 엔티티(자신)의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인
  - 위 코드 예시에서 order 테이블에는 user_id라는 FK 칼럼이 생기게 됨.

- 만약 생략할 경우 기본값은 `{필드명}_{참조 테이블의 PK 칼럼명}`이 된다.
  - 필드명이 user이고, 참조 테이블의 pk 칼럼이 id이기 때문에 user_id가 된다.

#### (2) @OneToMany일 때

- 상대 엔티티의 테이블에 생성될 FK 칼럼 이름.
  - 상대 엔티티의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인은 상대방 엔티티(테이블)

#### (3) 결론

- 결론적으로 FK는 Many쪽에 생성된다고 이해하면 된다.

### 2) referencedColumnName

- 참조 대상 테이블의 어느 칼럼을 FK로 가져갈지 정하는 속성
- 위 코드 예시에서 user 테이블의 id 칼럼을 참조한다고 명시
- 만약 생략할 경우 기본값은 상대 엔티티의 `@Id`어노테이션이 붙은 칼럼 (pk 칼럼)이 된다.
  - @OneToMany 관계일 경우에는 referencedColumnName은 현재 엔티티의 PK를 참조하기 때문에 사용하지 않는다. (의미가 없음)
  - @ManyToOne 관계일 때는 referencedColumnName이 중요하다.

- 대부분의 경우 상대 엔티티의 PK를 FK로 사용하는 경우가 많아서 생략 가능하지만, PK가 아닌 다른 unique 칼럼을 참조하거나 복합키일 때 필요하다.

<br>

## 2. mappedBy

mappedBy는 양방향 연관관계에서 한쪽에서만 FK를 실제로 관리하고, 나머지 한쪽은 읽기 전용으로 만들기 위한 설정이다.

- 연관 관계의 주인이 아닌 쪽에 명시하는 것이 원칙이다.
  - 연관 관계의 주인이란 FK 칼럼이 필드로 존재하는 엔티티이다.
- 따라서 대부분의 경우 연관 관계의 주인은 Many쪽이고 One은 주인이 아니다.
  - @OneToMany(mappedBy=...)을 많이 사용한다.

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")  // "나는 주인 아님, Order.user 필드가 주인"이라는 의미
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")  // 이쪽이 주인 (FK 관리)
    private User user;
}
```

### 1) "FK를 관리한다"의 의미

"DB 테이블 상에서 FK 값을 INSERT/UPDATE할 권한이 누구에게 있는가"

FK를 관리한다 == 실제 FK 칼럼을 수정할 수 있다.

```java
// 연관관계 주인(Order)에서 설정 → DB에 반영됨 ✅
Order order = new Order();
order.setUser(user);  // order 테이블의 user_id 컬럼에 값 들어감
em.persist(order);

// 주인이 아닌 쪽(User)에서 설정 → DB에 반영 안 됨 ❌
User user = new User();
user.getOrders().add(order);  // 이것만으론 order.user_id가 안 바뀜 -> order가 바뀌어야 하는데 실제 persist하는 대상 객체는 user임
em.persist(user);
```

FK 칼럼은 물리적으로 한 테이블에만 존재하기 때문에 FK 칼럼이 있는 엔티티가 그 값을 관리하는 것이 더 자연스러움.

만약 양쪽에서 다 관리를 하면

- order.setUser(user_A)하고, user_B.getOrders().add(order)을 하게되면 order 입장에서 FK는 user_A인가 user_B인가? => 충돌이 발생하는 셈이다.

그래서 FK의 주인인 엔티티에서 FK를 관리하는 것이 자연스럽기 때문에 이렇게 설계한 것이다.

#### (1) FK 주인 선정 팁

부(보조) 엔티티가 FK의 주인이 되는 게 가장 일반적이며 표준이다.

- "독립적 실체(메인이 되는 주체, 존재가 가장 우선적)" == 주 테이블
- "해당 실체의 부가 정보(옵션, 상태, 기록 등)" == 부 테이블 (FK 주인)

즉, 위의 예시에서도 주문과 사용자의 관계를 보면 주문은 사용자가 없으면 존재할 수 없기 때문에 사용자 엔티티가 주 테이블이 되고, 주문 엔티티가 부 엔티티가 되어 FK의 주인이 된 것이다.

<br>

## 3. orphanRemoval

### 1) 고아 객체 (Orphan Object)

부모 - 자식 연관 관계에서 부모와 자식의 참조 관계가 없어져 부모 소유의 컬렉션에서 없어지거나 자식의 부모 참조가 null이 되었을 때 주인이 없어진 객체를 말한다.

즉, 서로 연관 관계(주인에 속해있는 상태)에 있는 객체가 연관 관계가 끊겨서 주인이 없어져 참조가 없어진 객체를 고아 객체라고 한다.

### 2) cascade 옵션과 orpahnRemoval

`cascade = CascadeType.REMOVE` 혹은 `cascade = CascadeType.ALL`, 그리고 `orphanRemoval = true`는 비슷하지만 차이점이 존재한다.

#### (1) 공통점

##### cascade 옵션 (CascadeType.REMOVE, CascadeType.ALL)

1:N 혹은 N:1 연관관계 맵핑 어노테이션에서 cascade 옵션을 줄 수 있는데, CascadeType.REMOVE 혹은 CascadeType.ALL으로 설정하면 부모 객체가 삭제되면 자식 객체도 같이 삭제된다.

즉, 부모 객체 자체를 삭제할 때 연결된 모든 자식 객체도 한 번에 같이 삭제하는 옵션이다.

##### orpahnRemoval = true

마찬가지로 1:N 혹은 N:1 연관관계 맵핑 어노테이션에서 설정할 수 있는 옵션 중 하나로, 부모 객체의 컬렉션에서 자식을 제거하거나, 자식이 참조하고 있는 부모 관계를 null로 만들어 끊어버리면 자식 객체가 삭제되는 옵션이다.

즉, 부모의 컬렉션에서 자식을 제거하면 DB에서도 실제 해당 자식 데이터가 삭제된다.

기본값은 false이다. (orpahnRemoval = false)

따라서 고아 객체는 주인 관계가 없어져 참조가 없는데 DB 상에서는 남아있는 데이터를 말한다.

#### (2) 차이점

cascade의 경우 부모를 삭제했을 때 자식이 함께 같이 삭제되는 반면, orpahnRemoval은 부모와 자식 간의 참조가 끊겼을 때만 자식이 고아 객체가 되었으니 DB에서 삭제한다.

즉, orpahnRemoval = true 옵션을 사용하면 부모는 삭제되지 않더라도 자식이 삭제될 수도 있다.

cascade 옵션과 orpahnRemoval 옵션은 삭제 트리거에서 차이가 있는 셈이다.

- cascade는 부모의 변화 → 자식 전파가 목적이다. (※ cascade 방향을 잘못 설정하면 큰 문제가 생기기 때문에 설정 시 항상 부모 → 자식 방향으로 설정을 했는지 유의해야 한다.)
- orphanRemoval은 부모나 자식 둘 중 하나에서 관계를 끊을 수 있다. 다만 관계가 끊기는 순간 자식 객체는 사라짐을 유의.

### 3) orphanRemoval 실무 예시

#### (1) 게시글(부모)와 첨부파일(자식)

```java
@Entity
public class Post {
    @OneToMany(mappedBy="post", orphanRemoval = true)
    private List<Attachment> attachments;
}
```

- 사용자가 게시글을 수정하여 첨부파일 중 하나를 삭제함.
- 해당 첨부파일만 실제 DB에서 삭제될 뿐, 나머지 첨부파일에는 영향이 없음.
- 해당 게시글에서 삭제한 첨부파일을 굳이 데이터로 남길 필요가 없으니 삭제함.
  - 로그로만 남기면 될 뿐 굳이 삭제한 첨부에 대한 데이터를 남겨놓을 필요는 없음.
  - 경우에 따라 바로 삭제하지 않고 나중에 에이징시킬 수도 있음.

#### (2) 주문(부모)와 주문 상품(자식)

```java
@Entity
public class Order {
    @OneToMany(mappedBy="order", orphanRemoval = true)
    private List<OrderLine> orderLines;
}
```

- 주문에서 주문 상품을 하나 삭제함. (주문 상품 != 상품)
- 주문은 살아있는 상태이지만, 삭제한 주문 상품은 굳이 DB 상에서 가지고 있을 필요가 없으므로 삭제함.

<br>

## 4. JPA에서 복합 Unique 제약 방법

엔티티를 구성하다 보면 특정 필드의 조합을 unique하게 가져가야 하는 경우가 있다.

option, setting 혹은 키와 밸류 쌍을 담고 있는 정보 테이블 등이 그러하다.

@Table 어노테이션에서 uniqueConstraints 속성을 사용하면 필드 간의 조합을 유니크하게 가져갈 수 있다.

- 아래 예시는 (type, key, value)의 조합이 unique해야 함을 제약 조건으로 건 예시이다.

```java
@Entity
@Table(
        name = "option_config",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"type", "key", "value"})
        }
)
public class OptionConfig {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String type;

    @Column(nullable = false)
    private String key;

    @Column(nullable = false)
    private String value;
}
```

<br>

## 5. JPA 기본 메서드

JPA에서는 엔티티의 필드명을 조합하여 Repository에서 JPA 기본 메서드라는 메서드를 생성할 수 있다.

해당 메서드는 직접 쿼리를 작성하거나 할 필요 없이 필드명을 통해 조회 조건을 간단한 수준에서 정의하여 메서드로 간단하게 사용할 수 있다.

### 1) JPA 기본 메서드 VS Java 스트림

JPA에서 제공하는 메서드를 사용하는 것이 Java 스트림이나 로직을 통해 처리하는 것보다 성능, 최적화, 유지보수 측면에서 더 뛰어나다.

- JPA 메서드 사용 시 필터링 조건에 따라 필요한 데이터만 DB상에서 가져오기 때문에 필요없는 데이터가 메모리에 로드되지 않는다.
- JPA ORM 프레임워크 내부에서 인덱싱, 페이징, 캐시 등 모든 최적화가 이루어진 상태에서 조회가 이루어진다. 따라서 데이터 양이 많을 때 스트림보다 훨씬 뛰어나다.
