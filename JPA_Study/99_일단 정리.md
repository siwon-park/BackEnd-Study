# 99_일단 정리



## 1. @JoinColumn

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;
}

@Entity
public class User {
    @Id
    private Long id;
    private String name;
}
```

### 1) name

- 현재 엔티티의 테이블에 생성될 FK(외래키) 칼럼 이름
- 위 코드 예시에서 order 테이블에는 user_id라는 FK 칼럼이 생기게 됨
- 만약 생략할 경우 기본값은 `{필드명}_{참조 테이블의 PK 칼럼명}`이 된다.
  - 필드명이 user이고, 참조 테이블의 pk 칼럼이 id이기 때문에 user_id가 된다.

### 2) referencedColumnName

- 참조 대상 테이블의 어느 칼럼을 FK로 가져갈지 정하는 속성
- 위 코드 예시에서 user 테이블의 id 칼럼을 참조한다고 명시
- 만약 생략할 경우 기본값은 상대 엔티티의 `@Id`어노테이션이 붙은 칼럼 (pk 칼럼)이 된다.
- 대부분의 경우 상대 엔티티의 PK를 FK로 사용하는 경우가 많아서 생략 가능하지만, PK가 아닌 다른 unique 칼럼을 참조하거나 복합키일 때 필요하다.

<br>

## 2. mappedBy

mappedBy는 양방향 연관관계에서 한쪽에서만 FK를 실제로 관리하고, 나머지 한쪽은 읽기 전용으로 만들기 위한 설정이다.

연관 관계의 주인이 아닌 쪽에 명시하는 것이 원칙이다.

연관 관계의 주인이란 FK 칼럼이 필드로 존재하는 엔티티이다.

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")  // "나는 주인 아님, Order.user 필드가 주인"이라는 의미
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")  // 이쪽이 주인 (FK 관리)
    private User user;
}
```

### 1) "FK를 관리한다"의 의미

"DB 테이블 상에서 FK 값을 INSERT/UPDATE할 권한이 누구에게 있는가"

FK를 관리한다 == 실제 FK 칼럼을 수정할 수 있다.

```java
// 연관관계 주인(Order)에서 설정 → DB에 반영됨 ✅
Order order = new Order();
order.setUser(user);  // order 테이블의 user_id 컬럼에 값 들어감
em.persist(order);

// 주인이 아닌 쪽(User)에서 설정 → DB에 반영 안 됨 ❌
User user = new User();
user.getOrders().add(order);  // 이것만으론 order. user_id가 안 바뀜
em.persist(user);
```

FK 칼럼은 물리적으로 한 테이블에만 존재하기 때문에 FK 칼럼이 있는 엔티티가 그 값을 관리하는 것이 더 자연스러움.

만약 양쪽에서 다 관리를 하면

- order.setUser(user_A)하고, user_B.getOrders().add(order)을 하게되면 order 입장에서 FK는 user_A인가 user_B인가? => 충돌이 발생하는 셈이다.

그래서 FK의 주인인 엔티티에서 FK를 관리하는 것이 자연스럽기 때문에 이렇게 설계한 것이다.



## 3. orphanRemoval ?