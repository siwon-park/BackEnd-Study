# 99_일단 정리

> 일단 정리하고, 나중에 분류해서 구분하자

## 0. JPA가 자동으로 중계 테이블을 생성할 때

### 1) @ManyToMany

다대다 관계일 때 JPA는 자동으로 중계 테이블을 생성한다.

```java
@Entity
public class Member {
    @ManyToMany //  member_team(혹은 team_member)와 같은 중계 테이블 자동 생성
    private List<Team> teams;
}
```

### 2) @OneToMany 단방향 + @JoinColumn이 없을 때

@OneToMany 단방향 + @JoinColumn이 없을 때는 JPA입장에서는 어디에 FK를 둘지 알 수 없기 때문에 중간 테이블을 자동으로 생성하여 연관 관계를 관리한다.

```java
@Entity
public class Parent {
    @OneToMany
    private List<Child> children;
}

@Entity
public class Child {
    // 아무 매핑 없음
}
```

#### (1) @ManyToOne 단방향 + @JoinColumn이 없을 때

@ManyToOne 단방향 + @JoinColumn이 없을 때는 Many쪽에 FK 칼럼을 만든다.

관계 주인이 항상 Many쪽이기 때문에 중간 테이블을 자동으로 생성하지 않는다.

#### (2) @OneToMany 단방향 (@JoinColumn 없음) 과 동작이 다른 이유

결론적으로 JPA 디자인 철학상 "@ManyToOne만 있어도 FK가 어디에 들어가야 할지 JPA가 무조건 명확히 알 수 있다"고 보기 때문.

- JPA에서는 주인(Owner)가 누구인지 정하는 것이 핵심이다.
  - 양방향 맵핑 관계일 때는 반드시 관계의 주인이 누구인지 정해줘야 한다.
  - 그런데 단방향 관계에서는 연관 관계 어노테이션이 있는 쪽을 기본적으로 관계의 주인으로 본다.
  - 여기서 @OneToMany의 경우 One이 연관 관계의 주인이지만 FK를 역방향으로 둘 수 없고, 반대편의 관계의 엔티티의 어떤 칼럼으로 One쪽을 지칭할지 모른다.
    - "내가 B라는 엔티티를 관리해"라고 했지만 정작 B 엔티티쪽에는 A엔티티에 관한 정보가 없다. (A엔티티의 어떤 칼럼을 볼지 모른다.)
    - FK를 Many쪽에 놓고 싶지만 어떤 칼럼으로 관계를 맺을지 알 수 없어서 자동으로 FK를 두게 할 수  없다. (즉, 상대방 테이블의 어떤 칼럼을 외래키로 삼을지 모르기 때문에 못하는 것임)
    - 그래서 중계 테이블을 생성하는 것이다.
  - 하지만 @ManyToOne의 경우 어노테이션을 쓴 Many쪽이 연관 관계 주인이고, FK를 둘 수 있기 때문에 자동으로 FK를 생성하는 것이다.
    - 즉, @ManyToOne 단방향 관계를 사용한다는 것 자체가 Many쪽인 자신에게 FK 칼럼을 만들겠다와 같은 의미를 지니고 있다.

<br>

## 1. @JoinColumn

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;
}

@Entity
public class User {
    @Id
    private Long id;
    private String name;
}
```

### 1) name

#### (1) @ManyToOne일 때

- 현재 엔티티의 테이블에 생성될 FK(외래키) 칼럼 이름.
  - 현재 엔티티(자신)의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인
  - 위 코드 예시에서 order 테이블에는 user_id라는 FK 칼럼이 생기게 됨.

- 만약 생략할 경우 기본값은 `{필드명}_{참조 테이블의 PK 칼럼명}`이 된다.
  - 필드명이 user이고, 참조 테이블의 pk 칼럼이 id이기 때문에 user_id가 된다.

#### (2) @OneToMany일 때

- 상대 엔티티의 테이블에 생성될 FK 칼럼 이름.
  - 상대 엔티티의 테이블에 정의한 이름으로 FK 칼럼이 만들어짐 == FK의 주인은 상대방 엔티티(테이블)

#### (3) 결론

- 결론적으로 FK는 Many쪽에 생성된다고 이해하면 된다.

### 2) referencedColumnName

- 참조 대상 테이블의 어느 칼럼을 FK로 가져갈지 정하는 속성
- 위 코드 예시에서 user 테이블의 id 칼럼을 참조한다고 명시
- 만약 생략할 경우 기본값은 상대 엔티티의 `@Id`어노테이션이 붙은 칼럼 (pk 칼럼)이 된다.
  - @OneToMany 관계일 경우에는 referencedColumnName은 현재 엔티티의 PK를 참조하기 때문에 사용하지 않는다. (의미가 없음)
  - @ManyToOne 관계일 때는 referencedColumnName이 중요하다.

- 대부분의 경우 상대 엔티티의 PK를 FK로 사용하는 경우가 많아서 생략 가능하지만, PK가 아닌 다른 unique 칼럼을 참조하거나 복합키일 때 필요하다.

<br>

## 2. mappedBy

mappedBy는 양방향 연관관계에서 한쪽에서만 FK를 실제로 관리하고, 나머지 한쪽은 읽기 전용으로 만들기 위한 설정이다.

- 연관 관계의 주인이 아닌 쪽에 명시하는 것이 원칙이다.
  - 연관 관계의 주인이란 FK 칼럼이 필드로 존재하는 엔티티이다.
- 따라서 대부분의 경우 연관 관계의 주인은 Many쪽이고 One은 주인이 아니다.
  - @OneToMany(mappedBy=...)을 많이 사용한다.

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")  // "나는 주인 아님, Order.user 필드가 주인"이라는 의미
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")  // 이쪽이 주인 (FK 관리)
    private User user;
}
```

### 1) "FK를 관리한다"의 의미

"DB 테이블 상에서 FK 값을 INSERT/UPDATE할 권한이 누구에게 있는가"

FK를 관리한다 == 실제 FK 칼럼을 수정할 수 있다.

```java
// 연관관계 주인(Order)에서 설정 → DB에 반영됨 ✅
Order order = new Order();
order.setUser(user);  // order 테이블의 user_id 컬럼에 값 들어감
em.persist(order);

// 주인이 아닌 쪽(User)에서 설정 → DB에 반영 안 됨 ❌
User user = new User();
user.getOrders().add(order);  // 이것만으론 order.user_id가 안 바뀜 -> order가 바뀌어야 하는데 실제 persist하는 대상 객체는 user임
em.persist(user);
```

FK 칼럼은 물리적으로 한 테이블에만 존재하기 때문에 FK 칼럼이 있는 엔티티가 그 값을 관리하는 것이 더 자연스러움.

만약 양쪽에서 다 관리를 하면

- order.setUser(user_A)하고, user_B.getOrders().add(order)을 하게되면 order 입장에서 FK는 user_A인가 user_B인가? => 충돌이 발생하는 셈이다.

그래서 FK의 주인인 엔티티에서 FK를 관리하는 것이 자연스럽기 때문에 이렇게 설계한 것이다.

#### (1) FK 주인 선정 팁

부(보조) 엔티티가 FK의 주인이 되는 게 가장 일반적이며 표준이다.

- "독립적 실체(메인이 되는 주체, 존재가 가장 우선적)" == 주 테이블
- "해당 실체의 부가 정보(옵션, 상태, 기록 등)" == 부 테이블 (FK 주인)

즉, 위의 예시에서도 주문과 사용자의 관계를 보면 주문은 사용자가 없으면 존재할 수 없기 때문에 사용자 엔티티가 주 테이블이 되고, 주문 엔티티가 부 엔티티가 되어 FK의 주인이 된 것이다.

### 2) mappedBy 명시 이유

mappedBy 속성을 명시하는 이유는 FK 관리 주체를 한쪽으로만 명확하게 정하기 위해서이다.

#### (1) 객체와 DB 테이블의 차이

- DB 테이블의 경우 FK 하나만 알고 있으면 양쪽 테이블을 조인해서 정보를 다 가져올 수 있고, 업데이트도 할 수 있다. (방향이 없음)
- 하지만 자바 객체의 경우, 양방향 관계를 만들려면 참조 변수가 2개 필요하다. (A → B, B → A)
- 그런데 자바 객체에서 양쪽 다 값을 수정했을 때, DB의 어느 칼럼을 업데이트 해야 하는가에 대한 의문과 혼란이 생긴다. 물론 둘 다 해도 상관은 없겠지만 한쪽에서만 데이터를 수정하는 것이 정합성 보장에 더 유리할 수밖에 없다.

#### (2) mappedBy의 역할

- mappedBy의 의미는 FK의 관리 주체가 Many쪽이며, mappedBy 속성으로 지정한 필드명(변수명)이라고 선언하는 것이다.
- 즉, mappedBy 속성을 가진 쪽에서는 나는 FK의 주인이 아니다라는 것을 의미하며, 주인은 @JoinColumn을 가진쪽이다는 것을 뜻한다.
  - @JoinColumn을 명시한 필드를 가진 엔티티에서 FK 칼럼을 생성/수정/삭제할 수 있는 권한을 갖게 된다.

#### (3) mappedBy 이점

- 데이터 정합성 보장
  - 양쪽 객체에 다른 값을 넣더라도 결국 한쪽에서만 컨트롤 할 수 있기 때문에 데이터 정합성이 보장된다.
- 성능 최적화
  - 주인만 관리하면 되기 때문에 불필요한 UPDATE 쿼리를 날릴 필요가 없어진다.
- 코드 가독성(명확성)
  - 어떤 엔티티가 외래키를 물리적으로 가지고 있는지, 관계 등을 코드를 통해서도 명확하게 알 수 있다. 

<br>

## 3. orphanRemoval

### 1) 고아 객체 (Orphan Object)

부모 - 자식 연관 관계에서 부모와 자식의 참조 관계가 없어져 부모 소유의 컬렉션에서 없어진, 주인이 없어진 객체를 말한다. 즉, 서로 연관 관계(주인에 속해있는 상태)에 있는 객체가 연관 관계가 끊겨서 주인이 없어져 참조가 없어진 객체를 고아 객체라고 한다.

orphanRemoval = false (기본값)인 상태에서 부모와 자식 간의 연관 관계가 끊겨졌는데 DB상에 남아있는 객체를 고아 객체라고 하는 것이다.

### 2) cascade 옵션과 orpahnRemoval

`cascade = CascadeType.REMOVE` 혹은 `cascade = CascadeType.ALL`, 그리고 `orphanRemoval = true`는 비슷하지만 차이점이 존재한다.

#### (1) cascade 옵션 (CascadeType.REMOVE, CascadeType.ALL)

1:N 혹은 N:1 연관관계 맵핑 어노테이션에서 cascade 옵션을 줄 수 있는데, CascadeType.REMOVE 혹은 CascadeType.ALL으로 설정하면 부모 객체가 삭제되면 자식 객체도 같이 삭제된다.

즉, 부모 객체 자체를 삭제할 때 연결된 모든 자식 객체도 한 번에 같이 삭제하는 옵션이다.

#### (2) orpahnRemoval = true

마찬가지로 1:N 혹은 N:1 연관관계 맵핑 어노테이션에서 설정할 수 있는 옵션 중 하나로, 부모 객체와 연관관계가 끊겼을 때 DB에서 해당 자식 데이터를 삭제하는 옵션이다.

기본값은 false이다. (orpahnRemoval = false)

부모 객체와의 관계를 끊는 것은

- 부모 객체를 삭제했을 때
- 또는 부모의 컬렉션에서 자식을 제거할 때

를 의미한다.

#### (3) 공통점

부모의 변화 → 자식 전파

- cascade는 부모의 변화 → 자식 전파되어 부모가 삭제될 때만 연관된 자식 객체도 전부 다 삭제된다.
  - ※ cascade 방향을 잘못 설정하면 큰 문제가 생기기 때문에 설정 시 항상 부모 → 자식 방향으로 설정을 했는지 유의해야 한다. 만약 자식 to 부모로 설정하면 자식이 삭제되었을 때 부모가 삭제되는 대참사가 발생할 수도 있다.
- orphanRemoval 역시 부모 → 자식의 방향성을 갖는다.
  - 단, 자식 쪽에서 부모의 참조를 null로 만들 경우에는 참조만 끊는 것이며, 자식은 삭제되지 않음을 유의해야 한다.
  - 따라서 고아 객체의 삭제는 반드시 부모 엔티티 쪽에서 자식과의 연관 관계를 끊는 식으로 이루어져야 한다.

#### (4) 차이점

cascade의 경우 부모를 삭제했을 때만 자식이 함께 같이 삭제되는 반면, orpahnRemoval은 부모의 삭제를 포함하여 부모와 자식 간의 참조가 끊겼을 때(부모에서 자식의 참조를 해제했을 때) DB에서 삭제한다.

즉, orpahnRemoval = true 옵션을 사용하면 부모는 삭제되지 않더라도 자식이 삭제될 수도 있다.

cascade 옵션과 orpahnRemoval 옵션은 삭제 트리거에서 차이가 있는 셈이다.

### 3) orphanRemoval 실무 예시

#### (1) 게시글(부모)와 첨부파일(자식)

```java
@Entity
public class Post {
    @OneToMany(mappedBy="post", orphanRemoval = true)
    private List<Attachment> attachments;
}
```

- 사용자가 게시글을 수정하여 첨부파일 중 하나를 삭제함.
- 해당 첨부파일만 실제 DB에서 삭제될 뿐, 나머지 첨부파일에는 영향이 없음.
- 해당 게시글에서 삭제한 첨부파일을 굳이 데이터로 남길 필요가 없으니 삭제함.
  - 로그로만 남기면 될 뿐 굳이 삭제한 첨부에 대한 데이터를 남겨놓을 필요는 없음.
  - 경우에 따라 바로 삭제하지 않고 나중에 에이징시킬 수도 있음.

#### (2) 주문(부모)와 주문 상품(자식)

```java
@Entity
public class Order {
    @OneToMany(mappedBy="order", orphanRemoval = true)
    private List<OrderLine> orderLines;
}
```

- 주문에서 주문 상품을 하나 삭제함. (주문 상품 != 상품)
- 주문은 살아있는 상태이지만, 삭제한 주문 상품은 굳이 DB 상에서 가지고 있을 필요가 없으므로 삭제함.

### 3) 유의 사항

#### (1) 자식 타입 필드가 단일 객체일 경우

부모 객체 입장에서 @OneToOne, @ManyToOne 연관 관계로 자식 타입 필드가 단일 객체일 경우에는 부모 → 자식의 연관 관계를 끊기 위해서는 해당 객체를 null로 초기화시켜주면 된다.

#### (2) 자식 타입 필드가 컬렉션일 경우

하지만 @OneToMany, @ManyToMany와 같이 자식 타입 필드가 List, Set과 같은 컬렉션 타입일 경우에는 이야기가 달라진다.

이 경우 부모 - 자식 간의 연관 관계를 끊기 위해서는 필드 자체를 null 혹은 빈 리스트 또는 다른 컬렉션으로 초기화하면 안 되고, `.clear()`나 `.remove(자식 필드)`를 사용해서 연관 관계를 끊어줘야 한다.

왜 그럴까?

- 만약 해당 필드에 null 혹은 빈 객체, 다른 컬렉션으로 직접 할당을 하면, 이는 Hibernate를 통해 DB에서 데이터를 가져와서 자식 필드에 넣어둔 영속성 가방(Persistent Bag)를 버리고, 사용자가 직접 작성한 일반 데이터로 갈아 끼우는 셈이다. 
  - 이 경우 디버그 로그 상으로 해당 필드가 immutableList 혹은 다른 일반 컬렉션 타입이 된 것을 확인할 수 있다.
- 그러면 Hibernate 입장에서는 원래 영속성 바구니에 들어있던 객체가 뭐였는지 추적할 수 없게 되어 orphanRemoval=true가 동작하지 않고 DB상에 고아 객체로 남게 될 수도 있다.
- 혹은 Hibernate 쪽에서 에러를 반환하여 트랜잭션이 롤백될 수도 있다.
  - A collection with cascade="all-delete-orphan" was no longer referenced....
- 따라서 관계만 끊을 때는 .clear() 혹은 .remove()를 사용하고, 빈 값을 포함한 다른 값으로 할당하고자 할 때는 비운 다음에 .addAll()을 사용하여 할당해주는 것이 올바른 방식이다. 

<br>

## 4. JPA에서 복합 Unique 제약 방법

엔티티를 구성하다 보면 특정 필드의 조합을 unique하게 가져가야 하는 경우가 있다.

option, setting 혹은 키와 밸류 쌍을 담고 있는 정보 테이블 등이 그러하다.

@Table 어노테이션에서 uniqueConstraints 속성을 사용하면 필드 간의 조합을 유니크하게 가져갈 수 있다.

- 아래 예시는 (type, key, value)의 조합이 unique해야 함을 제약 조건으로 건 예시이다.

```java
@Entity
@Table(
        name = "option_config",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"type", "key", "value"})
        }
)
public class OptionConfig {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String type;

    @Column(nullable = false)
    private String key;

    @Column(nullable = false)
    private String value;
}
```

<br>

## 5. JPA 기본 메서드

JPA에서는 엔티티의 필드명을 조합하여 Repository에서 JPA 기본 메서드라는 메서드를 생성할 수 있다.

해당 메서드는 직접 쿼리를 작성하거나 할 필요 없이 필드명을 통해 조회 조건을 간단한 수준에서 정의하여 메서드로 간단하게 사용할 수 있다.

### 1) JPA 기본 메서드 VS Java 스트림

JPA에서 제공하는 메서드를 사용하는 것이 Java 스트림이나 로직을 통해 처리하는 것보다 성능, 최적화, 유지보수 측면에서 더 뛰어나다.

- JPA 메서드 사용 시 필터링 조건에 따라 필요한 데이터만 DB상에서 가져오기 때문에 필요없는 데이터가 메모리에 로드되지 않는다.
- JPA ORM 프레임워크 내부에서 인덱싱, 페이징, 캐시 등 모든 최적화가 이루어진 상태에서 조회가 이루어진다. 따라서 데이터 양이 많을 때 스트림보다 훨씬 뛰어나다.

<br>

## 6. List 타입 컬렉션 필드 초기화 주의

`private List<T> list`와 같이 List 타입의 필드를 초기화할 때는 반드시 `new ArrayList<>()`로 초기화시켜줘야 한다.

절대 List.of()로 초기화해서는 안 된다.

왜냐하면 List.of()로 만든 리스트는 불변 리스트(immutable)이기 때문에 수정이 불가능하다.

JPA/Hibernate에서는 연관관계 컬렉션을 트랙킹하고 요소를 추가하기 위해 내부적으로 add, remove, clear 등을 사용하는데, List.of()를 쓰면 해당 메서드를 호출하는 순간 UnsupportedOperationException 예외가 발생한다.

또한 cascade, orphanRemoval과 같이 JPA가 직접 컬렉션을 수정하는 모든 시나리오에서 불변 리스트는 치명적인 문제를  발생시킨다 => 예) 초기화 불가능

따라서 반드시 가변 리스트(mutable)인 ArrayList로 선언을 해줘야 한다. 

<br>

## 7. QueryDsl에서의 DTO 맵핑

querydsl을 사용하여 DB에서 데이터를 조회해온 후 DTO를 맵핑할 때, 총 3가지의 방법이 존재한다.

### 1) 엔티티 조회 후 직접 맵핑

일반적인 jpa repository에서 조회해오는 방식과 동일하게 반환 타입을 엔티티로 설정 후 서비스 레이어에서 dto를 생성하여 컨트롤러로 반환한다.

#### (1) 장점

- 코딩하는 방식이 repository에서 직접 조회 후 처리하는 방식과 동일하다보니 익숙함.
- 컴파일러에 의해 dto 생성 시 타입 안정성 체크 가능.

#### (2) 단점

- 엔티티 → DTO로 맵핑을 해줘야 하므로 전처리 과정을 한 번 더 거쳐야 한다는 점에서 번거로움이 있다.

### 2) QDTO 사용

DTO의 생성자에 querydsl에서 제공하는 `@QueryProjection` 어노테이션을 붙여서 엔티티를 Q클래스화 하듯이 QDTO를 만들어서 쿼리에서 직접 조회하는 동시에 맵핑하는 방식으로 사용할 수 있다.

```java
// DTO
public class MemberDto {
    @QueryProjection
    public MemberDto(String username, int age) { ... 중략 ... }
}

// querydsl repository
.select(new QMemberDto(member.username, member.age)) // 조회하면서 QDTO에 맵핑
.fetch();
```

#### (1) 장점

- 일반적인 new 키워드를 통한 DTO 생성과 마찬가지로 컴파일 시점에 체크가 가능하다.
- new 키워드를 써서 직관적이고 일반적으로 많이 사용하는 방식과 동일한 스타일로 코딩이 가능하다.

#### (2) 단점

- DTO가 querydsl이라는 특정 기술에 종속된다.
- DTO가 바뀔 때마다 컴파일을 새로하여 QDTO를 다시 생성해줘야 하는 번거로움이 생긴다.

### 3) Projections.constructor()

querydsl이 제공하는 유틸리티 클래스인 `Projections.constructor()`를 활용하여 런타임 시점에 DTO의 생성자를 찾아서 쿼리에서 조회해오면서 맵핑하는 방식이다.

```java
// querydsl repository
.select(Projections.constructor(MemberDto.class, member.username, member.age))
.fetch();
```

#### (1) 장점

- DTO가 querydsl을 몰라도 된다. (querydsl에 종속적이지 않은 dto)
- 별도의 설정 없이 사용할 수 있다.

#### (2) 단점

- 컴파일러가 에러를 잡지 못하고 런타임 시점에 문제를 확인할 수 있다. dto의 생성자 인자의 순서가 바뀌거나 타입을 잘못 넣어도 컴파일 시점에 잡지 못하고 런타임 시점에 쿼리를 실행하는 순간 알게된다.

