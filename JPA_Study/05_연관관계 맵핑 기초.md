# 05_연관 관계 맵핑

## 1. 객체 간 연관 관계가 필요한 이유

객체 지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.

DB 상에 존재하는 테이블을 객체 간의 유기적인 관계로 표현하기 위해서는 연관 관계 설정이 필수적이다.

### 1) 단방향? 양방향?

실제 DB 상에서는 테이블 간의 관계에서 방향이라는 개념은 존재하지 않는다.

그러나 객체 간에는 방향 관계라는 개념이 존재하며, 이러한 테이블을 객체로 표현했을 때 테이블 간의 관계에 따른 방향을 설정해줘야 한다.

DB 상에서는 쿼리를 통해서 관계가 있는 데이터를 조회할 수 있지만, 이를 객체화 한 다음에도 관계가 있는 객체를 함께 조회하거나 액션을 취하기 위해서는 방향 관계를 설정해줘야만 한다.

### 2) 객체를 단순히 테이블에 맞추어 모델링할 경우

테이블을 있는 그대로 객체화하여 모델링한다. 아래 예시에서는 teamId라는 Long 타입 외래키 필드를 직접 둬서 맵핑하는 예시이다. 

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private long id;
    
    @Column(name = "username")
    private String name;
    
    @Column(name = "team_id")
    private Long teamId; // 외래 키를 직접 맵핑
}

@Entity
public class Team {
    @Id @GeneratedValue
    private long id;
    ////...
}
```

그러나 외래키 식별자를 직접 다룰 경우에는 다음과 같은 문제가 발생한다.

```java
member.setTeamId(team.getId()); // 팀 객체에서 아이디를 뽑아와서 member객체에 set함

// 또한 팀을 가져올 때, 식별자를 통해 다시 가져와야한다
Member findMember = em.find(Member.class, member.getId());
Long findTeamId = findMember.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);
```

- 멤버를 생성할 때, 팀 객체를 가져와서 팀 객체 아이디를 멤버 객체에 set해줘야 한다.
- 또한 멤버가 속한 팀 객체를 가져와야 할 때는, 멤버 객체를 찾은 다음 멤버 객체의 팀 아이디를 통해 팀을 찾아서 가져와야 한다.

즉, 객체를 테이블에 맞추어 데이터 중심으로 모델링하면 객체 간 협력 관계를 만들 수 없다.

객체 지향의 관점에서 보면 어떤 객체는 다른 객체의 부모나 자식이 될 수 있어 바로 참조를 할 수 있는데, 이렇게 객체를 단순히 테이블에 맞추어서 데이터 중심적으로 모델링을 하게 되면 객체 지향적이라고 볼 수 없다.

<br>

## 2. 다양한 연관 관계 맵핑

> @ManyToOne, @OneToMany, @OneToOne, @ManyToMany

### 1) 연관 관계 맵핑 설정하기

JPA에서 연관 관계를 설정하기 위해서는 @ManyToOne, @OneToMany, @OneToOne, @ManyToMany와 같이 다양한 어노테이션이 존재한다.

이 어노테이션들은 엔티티의 특정 필드에 작성하며, 객체 간 연관 관계와 방향성, 그리고 개발 의도에 따라 적절한 어노테이션을 사용하여 맵핑해줘야 한다.

문자 그대로 읽으면 어떤 관계인지 확인할 수 있으나 객체 관계에 따라 어떤 어노테이션을 필드에 지정하는게 맞는지 처음에는 헷갈릴 수도 있다.

기본적인 핵심은 어노테이션을 다는 필드를 가진 객체 쪽이 To 앞의 관계를 가진다.

- 예) Team 객체에서 `List<User> members`라는 필드가 있을 때 "팀에는 여러 멤버가 속할 수 있다"는 부분을 고려하면 Team과 member(user)의 관계는 1:N이다. 따라서 @OneToMany를 작성해주면 된다.
- 반대로 User 입장에서는 Team이라는 필드가 있을 경우 @ManyToOne이 되는 셈이다.

### 2) 단방향 맵핑

한쪽의 엔티티의 필드에만 연관 관계 어노테이션을 작성하고 연관 관계의 대상인 상대방 엔티티에는 따로 연관 관계 어노테이션을 두지 않을 경우 이를 단방향 맵핑이라고 부른다.

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private long id;
    
    @Column(name = "username")
    private String name;
    
    @ManyToOne // 여러 회원이 팀에 소속될 수 있으므로 N:1 관계임
    @JoinColumn(name = "team_id") // 연관관계 맵핑할 칼럼 선택
    private Team team;
}
```

### 3) 양방향 맵핑

연관 관계에 놓여 있는 두 엔티티 모두에게 연관 관계 어노테이션을 두는 것을 양방향 맵핑이라고 한다.

```java
// Member 테이블에 @ManyToOne이 있는 상태에서 Team에도 @OneToMany가 있으면 양방향 관계이다.
@Entity
public class Team {
    // ....
    @OneToMany(mappedBy = "team")
   	private List<Member> members = new ArrayList<>();
    // ...
}
```



# 이하 정리 중 ...

<br>

### mappedBy

객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계가 2개 있는 셈이다.

테이블은 외래 키 하나로 두 테이블의 연관관계를 관리할 수 있다.

mappedBy는 사실상 읽기 전용이기 때문에 JPA에서 update 쿼리에 추가하지 않음



#### 양방향 맵핑 규칙

- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
- 주인이 아닌 쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정



#### 외래 키가 있는 곳을 주인으로 등록

#### N쪽이 주인으로 등록



### 주의점

양방향 맵핑 시 연관관계의 주인에 값을 입력해야 한다. => 그러나 사실상 객체지향적으로 봤을 때 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는 것을 권장

#### 방법1)

```java
member.setTeam(team);
team.getMebers().add(member);
```



#### 방법2)

setter 메서드 수정(혹은 새로운 메서드 생성 => set메서드의 이름 변형한 다른 메서드 선언)

이를 연관관계 편의 메서드라고 한다. 단, 연관관계 편의 메서드는 한쪽에만 생성하는 것이 좋다

```java
public void setTeam(Team team){
    this.team = team; // 기본
    team.getMembers().add(this); // 다른 한쪽에도 값을 추가
}
```

<br>

- 양방향 맵핑시 무한 루프를 조심
  - 예) toString, lombok, JSON생성 라이브러리
  - 양방향 맵핑으로 인해 서로를 계속해서 재귀적으로 호출하다보니 무한 루프 및 스택오버플로우 발생

- 이를 피하는 방법
  - 컨트롤러에서 API로 엔티티를 반환하지 말 것 => DTO로 변환해서 반환할 것

## 정리

- 단방향 맵핑만으로도 이미 연관관계 맵핑은 완료
- 양방향 맵핑은 반대 방향으로 조회할 수 있는 기능이 추가된 것일 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 맵핑을 잘 하는 것이 중요하고, 양방향은 필요할 때 추가해도 충분함(어차피 테이블에 영향이 없음)
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함(비즈니스 로직을 기준으로 정해서는 안 됨!)