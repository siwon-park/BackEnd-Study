# 05_연관 관계 맵핑

## 1. 객체 간 연관 관계가 필요한 이유

객체 지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.

DB 상에 존재하는 테이블을 객체 간의 유기적인 관계로 표현하기 위해서는 연관 관계 설정이 필수적이다.

### 1) 단방향? 양방향?

실제 DB 상에서는 테이블 간의 관계에서 방향이라는 개념은 존재하지 않는다.

그러나 객체 간에는 방향 관계라는 개념이 존재하며, 이러한 테이블을 객체로 표현했을 때 테이블 간의 관계에 따른 방향을 설정해줘야 한다.

DB 상에서는 쿼리를 통해서 관계가 있는 데이터를 조회할 수 있지만, 이를 객체화 한 다음에도 관계가 있는 객체를 함께 조회하거나 액션을 취하기 위해서는 방향 관계를 설정해줘야만 한다.

### 2) 객체를 단순히 테이블에 맞추어 모델링할 경우

테이블을 있는 그대로 객체화하여 모델링한다. 아래 예시에서는 teamId라는 Long 타입 외래키 필드를 직접 둬서 맵핑하는 예시이다. 

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private long id;
    
    @Column(name = "username")
    private String name;
    
    @Column(name = "team_id")
    private Long teamId; // 외래 키를 직접 맵핑
}

@Entity
public class Team {
    @Id @GeneratedValue
    private long id;
    ////...
}
```

그러나 외래키 식별자를 직접 다룰 경우에는 다음과 같은 문제가 발생한다.

```java
member.setTeamId(team.getId()); // 팀 객체에서 아이디를 뽑아와서 member객체에 set함

// 또한 팀을 가져올 때, 식별자를 통해 다시 가져와야한다
Member findMember = em.find(Member.class, member.getId());
Long findTeamId = findMember.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);
```

- 멤버를 생성할 때, 팀 객체를 가져와서 팀 객체 아이디를 멤버 객체에 set해줘야 한다.
- 또한 멤버가 속한 팀 객체를 가져와야 할 때는, 멤버 객체를 찾은 다음 멤버 객체의 팀 아이디를 통해 팀을 찾아서 가져와야 한다.

즉, 객체를 테이블에 맞추어 데이터 중심으로 모델링하면 객체 간 협력 관계를 만들 수 없다.

객체 지향의 관점에서 보면 어떤 객체는 다른 객체의 부모나 자식이 될 수 있어 바로 참조를 할 수 있는데, 이렇게 객체를 단순히 테이블에 맞추어서 데이터 중심적으로 모델링을 하게 되면 객체 지향적이라고 볼 수 없다.

<br>

## 2. 다양한 연관 관계 맵핑

> @ManyToOne, @OneToMany, @OneToOne, @ManyToMany

### 1) 연관 관계 맵핑 설정하기

JPA에서 연관 관계를 설정하기 위해서는 @ManyToOne, @OneToMany, @OneToOne, @ManyToMany와 같이 다양한 어노테이션이 존재한다.

이 어노테이션들은 엔티티의 특정 필드에 작성하며, 객체 간 연관 관계와 방향성, 그리고 개발 의도에 따라 적절한 어노테이션을 사용하여 맵핑해줘야 한다.

문자 그대로 읽으면 어떤 관계인지 확인할 수 있으나 객체 관계에 따라 어떤 어노테이션을 필드에 지정하는게 맞는지 처음에는 헷갈릴 수도 있다.

기본적인 핵심은 어노테이션을 다는 필드를 가진 객체 쪽이 To 앞의 관계를 가진다.

- 예) Team 객체에서 `List<User> members`라는 필드가 있을 때 "팀에는 여러 멤버가 속할 수 있다"는 부분을 고려하면 Team과 member(user)의 관계는 1:N이다. 따라서 @OneToMany를 작성해주면 된다.
- 반대로 User 입장에서는 Team이라는 필드가 있을 경우 @ManyToOne이 되는 셈이다.

### 2) 단방향 맵핑

한쪽의 엔티티의 필드에만 연관 관계 어노테이션을 작성하고 연관 관계의 대상인 상대방 엔티티에는 따로 연관 관계 어노테이션을 두지 않을 경우 이를 단방향 맵핑이라고 부른다.

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private long id;
    
    @Column(name = "username")
    private String name;
    
    @ManyToOne // 여러 회원이 팀에 소속될 수 있으므로 N:1 관계임
    @JoinColumn(name = "team_id") // 연관관계 맵핑할 칼럼 선택
    private Team team;
}
```

### 3) 양방향 맵핑

연관 관계에 놓여 있는 두 엔티티 모두에게 연관 관계 어노테이션을 두는 것을 양방향 맵핑이라고 한다.

```java
// Member 테이블에 @ManyToOne이 있는 상태에서 Team에도 @OneToMany가 있으면 양방향 관계이다.
@Entity
public class Team {
    // ....
    @OneToMany(mappedBy = "team")
   	private List<Member> members = new ArrayList<>();
    // ...
}
```



<br>

## 3. @ManyToMany

> 다대다 관계

엔티티 객체 간 N:M 관계에 놓여 있을 때 @ManyToMany를 사용한다.

예를 들어 사용자와 사용자 간에 서로 팔로우를 할 수 있다면, 팔로워-팔로잉의 관계인 N:M 관계가 성립한다.

- 하나의 유저는 여러 팔로워를 가질 수 있고, 다른 사용자들을 팔로잉할 수 있다.

N:M 관계의 @ManyToMany를 사용하면 JPA에서는 자동으로 중계 테이블을 생성해준다.

### 1) 단순 N:M 관계

단순 N:M ManyToMany 관계에서는 중복이 허용되지 않는다.

즉, A 사용자가 B 사용자, C사용자를 팔로우할 수 있지만, B 사용자 혹은 C 사용자를 중복해서 팔로우할 수는 없다.

중계 테이블의 pk의 값은 (A엔티티 pk, B엔티티 pk)로 구성되기 때문에 객체 A와 객체 B의 조합은 유일하기 때문에 중복으로 insert할 수 없다.

단순 N:M 관계에서 만들어지는 중간 테이블을 조인 테이블(Join Table)이라고 한다.

#### (1) 예시

학생과 동아리의 관계

- 하나의 학생은 여러 동아리에 속할 수 있다.
- 하나의 동아리에는 여러 학생이 속할 수 있다.
- 그러나 하나의 동아리 안에 학생1이 여러 번 등장할 수는 없다.

### 2) 중복을 허용하는 N:M 관계 (간접적 N:M)

그러나 실제 사례를 보면 중복을 허용해야 하는 N:M 관계가 빈번하게 존재한다.

추가 속성(횟수, 순서, 일시, 상태 등)이나 히스토리성 관계에 놓여있을 때 이러한 케이스가 종종 존재한다.

#### (1) 예시

사용자와 책의 관계 (정확히는 사용자와 대출 기록)

- 하나의 사용자는 여러 책을 빌릴 수 있다.
- 하나의 책은 여러 사용자에게 대출 가능하며, 한 사용자가 하나의 책에 대해 여러 번 대출을 할 수도 있다.

사용자와 책 간에는 N:M 관계에 있는 것처럼 보이지만, 실제로는 직접적인 N:M 관계가 아니라 간접적인 N:M 관계이며, 이를 확장 N:M 관계라고 부르기도 한다.

이렇게 N:M 관계에 있는 엔티티 간에 중복을 허용하려면 중간 엔티티라는 개념이 필요하다.

#### (2) 중간 엔티티

중간 엔티티(Associative Entity), 연결 엔티티(Link Entity), 속성을 가진 조인 테이블(Join Table With Attributes) 등으로 부르며, N:M 관계에서 중복을 허용하기 위해 생성한다.

수량, 순서, 일시, 상태 등의 추가 속성이 있으며 엔티티 간의 관계, 이력, 상태를 추적하기 위해 사용된다.

pk가 (A pk, B pk) 대신 id(PK 인조), (A, B, +부가정보) 등으로 확장된다.

#### (3) 실무 예시

작업자가 있고, 각 작업자는 여러 작업 큐에 속할 수 있으며 하나의 작업 큐 내에서 순서에 따라 중복을 허용할 수도 있다.

이 때에는 단순히 Worker, WorkerQueue만 있으면 되는 것이 아니라 WorkerQueueEntry라는 중간 엔티티가 필요하다.

```java
@Entity
public class WorkerQueueEntry {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "queue_id")
    private WorkerQueue queue;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "worker_id")
    private Worker worker;

    private Integer order;
}
```

이렇게 되면 WorkerQueueEntry의 pk인 id와 order라는 순서 속성에 따라 (queue_id, worker_id) 조합의 중복을 허용할 수 있게 된다.

Worker와 WorkerQueue에는 다음과 같이 mappedBy 속성을 통해 역방향 맵핑을 해주면 된다.

```java
@Entity
public class Worker {
    @Id @GeneratedValue
    private Long id;

    // ... 기타 컬럼 및 메서드
    
    // 역방향 매핑 (해당 작업자가 포함된 모든 엔트리)
    @OneToMany(mappedBy = "worker")
    private List<WorkerQueueEntry> queueEntries;
}

@Entity
public class WorkerQueue {
    @Id @GeneratedValue
    private Long id;

	// ... 기타 컬럼 및 메서드
    
    // 역방향 매핑 (이 큐에 있는 모든 엔트리)
    @OneToMany(mappedBy = "queue")
    private List<WorkerQueueEntry> queueEntries;
}
```

<br>

# 이하 정리 중 ...

<br>

### mappedBy

객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계가 2개 있는 셈이다.

테이블은 외래 키 하나로 두 테이블의 연관관계를 관리할 수 있다.

mappedBy는 사실상 읽기 전용이기 때문에 JPA에서 update 쿼리에 추가하지 않음



#### 양방향 맵핑 규칙

- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
- 주인이 아닌 쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정



#### 외래 키가 있는 곳을 주인으로 등록

#### N쪽이 주인으로 등록



### 주의점

양방향 맵핑 시 연관관계의 주인에 값을 입력해야 한다. => 그러나 사실상 객체지향적으로 봤을 때 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는 것을 권장

#### 방법1)

```java
member.setTeam(team);
team.getMebers().add(member);
```



#### 방법2)

setter 메서드 수정(혹은 새로운 메서드 생성 => set메서드의 이름 변형한 다른 메서드 선언)

이를 연관관계 편의 메서드라고 한다. 단, 연관관계 편의 메서드는 한쪽에만 생성하는 것이 좋다

```java
public void setTeam(Team team){
    this.team = team; // 기본
    team.getMembers().add(this); // 다른 한쪽에도 값을 추가
}
```

<br>

- 양방향 맵핑시 무한 루프를 조심
  - 예) toString, lombok, JSON생성 라이브러리
  - 양방향 맵핑으로 인해 서로를 계속해서 재귀적으로 호출하다보니 무한 루프 및 스택오버플로우 발생

- 이를 피하는 방법
  - 컨트롤러에서 API로 엔티티를 반환하지 말 것 => DTO로 변환해서 반환할 것

## 정리

- 단방향 맵핑만으로도 이미 연관관계 맵핑은 완료
- 양방향 맵핑은 반대 방향으로 조회할 수 있는 기능이 추가된 것일 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 맵핑을 잘 하는 것이 중요하고, 양방향은 필요할 때 추가해도 충분함(어차피 테이블에 영향이 없음)
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함(비즈니스 로직을 기준으로 정해서는 안 됨!)