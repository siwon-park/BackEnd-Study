# 03_영속성 컨텍스트

> Persistence Context

## 1. 영속성 컨텍스트

> JPA를 이해하는데 가장 중요한 용어

"엔티티를 영구 저장하는 환경"이라는 의미

```java
EntityManager.persist(entity);
```

영속성 컨텍스트는 논리적인 개념이기 때문에 눈에 보이지 않는다.

엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다

<br>

## 2. 엔티티의 생명 주기

### 1) 비영속(new, transient)

> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

```java
Member member = new Member();
member.setId = "1L";
member.setName = "siwon-park";
```

위의 Member 타입 객체는 DB나 어떠한 영속성과 관련이 없는 Java에서의 객체이다.

### 2) 영속(managed)

> 영속성 컨텍스트에 관리되는 상태

```java
// 비영속(new, transient)
Member member = new Member();
member.setId = "1L";
member.setName = "siwon-park";

EntityManager em = emf.createEntityManager();

// 영속(managed)성 상태
em.persist(member); 
```

엔티티 매니저를 통해 일반 java 객체를 persist하게 되면 영속성 컨텍스트에 의해 관리되는 영속성 상태가 된다.

영속성 상태가 되었다고 해서 DB에 저장되지 않으며, 실제 해당 트랜잭션이 커밋되어야만 DB에 저장된다.

### 3) 준영속(detached)

> 영속성 컨텍스와 연관되었다가 분리된(detached) 상태

```java
em.detach(member); // 영속성을 분리함
```

영속성 컨텍스트와 분리되어 준영속 상태가 될 경우 영속성 컨텍스트가 제공하는 기능을 사용하지 못하게 된다.

#### (1) 특징

- 이전에 한 번 영속되었기 때문에 반드시 id를 가지고 있다는 특징이 있다.
  - 위 예시에서 member 객체의 경우, id 값을 getter를 통해 추출할 수 있다.
- 값을 수정해도 더티 체킹(Dirty Checking)이 발생하지 않는다.
  - 영속성 컨텍스트가 관리할 경우 객체의 값만 변경했을 때도 DB 상의 데이터에 변경 사항이 발생할 수도 있으나, 준영속 상태가 되었을 때는 이러한 이벤트가 절대 발생하지 않는다.
- 지연 로딩을 통한 조회가 불가능하다.
  - 지연 로딩을 통해 객체 - 객체의 다리를 건너서 데이터를 조회하는 방식이 불가능하다.
  - 지연 로딩의 원리가 필요할 때 SQL 쿼리를 통해 데이터를 가져오는데, 더 이상 영속성 컨텍스트에 의해 관리되는 객체가 아니기 때문에 쿼리를 수행하지 못한다.
- 준영속 상태의 경우 영속성 컨텍스트와의 관계를 끊었을 뿐, 실제 데이터를 삭제하는 개념이 아니다. 따라서 객체를 준영속 상태로 만들고 트랜잭션을 커밋하더라도 DB상에는 데이터가 남아있다.
  - 준영속 상태의 객체를 .merge() 메서드를 통해서 다시 영속성 상태로 변경할 수도 있다.

#### (2) 준영속화 메서드

엔티티 매니저를 통해 detach(), clear(), close() 메서드를 호출하게 되면 준영속 상태로 변경할 수 있다.

- em.detach(entity)
  - 특정 엔티티만 준영속 상태로 전환
- em.clear()
  - 영속성 컨텍스트를 완전히 초기화 (비우기)
- em.close()
  - 영속성 컨텍스트를 종료
- 트랜잭션이 종료되어 영속성 컨텍스트가 사라졌을 때

### 4) 삭제(removed)

```java
em.remove(member); // 삭제
```

삭제 역시 영속성 컨텍스트가 관리하지 않는다는 점에서 준영속과 비슷하지만, 삭제 상태의 경우 해당 엔티티를 DB에서 삭제하기로 확정된 상태를 의미한다. (삭제 예약 상태)

em.remove(entity)를 호출하는 순간 데이터가 바로 지워지는 것이 아니라, 영속성 컨텍스트 상에서 삭제 대기 상태로 남아 있다가 트랜잭션이 커밋되는 순간 delete 쿼리가 호출된다.

삭제 상태의 경우 준영속 상태와 달리 .merge()를 호출하여 다시 영속성 상태로 만드는 것 자체가 불가능하다. 따라서 새로 만들어야 한다.

<br>

## 3. 영속성 컨텍스트의 이점

캐싱, 버퍼링 등의 이점을 얻기 위해 영속성 컨텍스트라는 매커니즘을 둔 것이다.

### 1) 1차 캐시

영속성 컨텍스트 사용 시 엔티티를 조회할 때, DB에서 바로 조회하지 않고 1차 캐시에서 조회하는 이점이 생긴다.

- 만약 1차 캐시에 없을 경우?
  - DB에서 먼자 찾고 1차 캐시에 저장을 한 다음, 이후에는 1차 캐시에서 찾는다.
    - 물론 찾고자하는 데이터가 DB에 기본적으로 있어야 한다.
  
- 그런데 이런 방식의 캐싱은 성능상 큰 이점을 얻을 수 있다고 볼 순 없다.
  - 왜냐하면 진짜 찰나의 시간에 이루어지는 것이기 때문에 요청이 종료되면 결국 1차 캐시도 사라지기 때문이다.


```java
em.persist(member);

Member findMember = em.find(Member.class, 101L);

// 조회 쿼리문이 나가지 않음 (select id from ..., select name from ... 쿼리 수행 X) -> 1차 캐시에서 조회하기 때문
System.out.println(findMember.getId());
System.out.println(findMember.getName());
```

### 2) 영속성 엔티티의 동일성 보장

일반적인 java 객체의 경우 분명히 같은 객체 같은데 참조하고 있는 주소값이 달라서 서로 다른 객체일 수도 있는 반면, 영속성 컨텍스트를 통해 가져온 엔티티 객체의 경우 조회 조건이 같다면 반드시 동일하다는 특징이 있다.

```java
Member a = em.find(Member.class, "Member1");
Member b - em.find(Member.class, "Member1");

System.out.println(a == b); // true
```

### 3) 트랜잭션을 지원하는 쓰기 지연

트랜잭션을 커밋하는 순간에 SQL문을 보낸다. 쿼리문을 생성하고 "쓰기 지연 SQL 저장소"에 저장해둔 다음 트랜잭션이 커밋되면 DB에 쿼리문을 보낸다.

즉, "저장해줘"라고 명령을 했지만 실제로 DB상에 저장되는 시점은 트랜잭션이 커밋되는 시점인 것이다.

```java
em.persist(memberA);
em.persist(memberB);
// 여기까지 SQL구문을 보내지 않음(JPA가 쌓고 있음)

tx.commit(); // 이 순간에 쿼리문을 보낸다.
```

이렇게 하는 이유는 한번에 모았다가 배치 단위로 보냄으로써 최적화가 가능하다.

### 4) 더티 체킹(Dirty Checking, 변경 감지)

> 엔티티의 상태 변화를 JPA가 감지해서 자동으로 DB에 반영하는 기능

Dirty는 "상태가 변경됨"을 의미한다.

JPA를 쓰는 목적에는 SQL 쿼리문의 동작 및 DB의 데이터를 자바 컬렉션처럼 자유롭게 쓰기 위함인데, 매번 연관된 객체를 save() 메서드를 호출해서 명시적으로 저장해야 한다면 로직/논리상으로 DB와 큰 차이가 없어 굳이 JPA를 써야하나 싶을 수도 있다.

그러나 JPA가 제공하는 더티 체킹을 통해서 (연관 관계에 있는) 데이터를 굳이 저장하지 않아도 트랜잭션 종료 시점에 자동으로 저장할 수 있다.

```java
@Service
public class MemberService {
    
    @Transactional // 필수!
    public void updateMember(Long id, String newName) {
        // 1. 엔티티 조회 (영속성 컨텍스트가 스냅샷 생성)
        Member member = memberRepository.findById(id).get();

        // 2. 값 수정 (자바 객체 내부 값만 바뀜)
        member.setName(newName);

        // 3. save()를 호출하지 않아도 트랜잭션 종료 시점에 자동으로 UPDATE 쿼리 실행!
    }
}
```

#### (1) 동작 원리

- 해당 트랜잭션 내에서 엔티티를 조회를 하면 영속성 컨텍스트에 저장한 다음에, 조회 당시의 스냅샷을 남긴다.
- 이후 엔티티의 필드를 업데이트를 하면, JPA가 1차 캐시, 스냅샷을 탐색하여 변경을 감지한다.
- 트랜잭션이 끝나서 커밋 혹은 flush되는 순간, JPA는 현재 엔티티와 처음에 조회 당시 저장한 스냅샷을 비교하여 차이가 있을 경우 업데이트 쿼리를 작성하여 DB로 보낸다.

#### (2) 동작 조건

- 반드시 영속성 컨텍스트가 관리하는 객체여야 한다.
  - findBy...으로 가져온 객체여야 하며 new 키워드를 통해 새로 생성한 엔티티 객체는 해당되지 않는다.
- 트랜잭션 범위 내에서 있어야 한다.
  - @Transactional 어노테이션이 붙은 메서드 안에서 수행되는 작업이어야만 한다. 트랜잭션이 끝날 때 JPA가 변경사항을 감지하여 동작을 수행하기 때문에 그렇다.

#### (3) 더티 체킹이 동작하지 않는 경우

다음과 같은 상황에서는 더티 체킹이 동작하지 않기 때문에 반드시 save() 메서드를 명시적으로 호출해야 한다.

- 트랜잭션 밖에서 객체를 수정한 경우
  - 예) 객체를 컨트롤러까지 들고 나갔다가 거기서 setter를 통해 수정했을 경우
  - 이 경우에는 해당 객체는 이미 트랜잭션이 끝난 준영속 상태가 되었기 때문에 JPA가 더 이상 변경 사항을 추적하지 않는다.
- 트랜잭션이 없는 경우
  - 트랜잭션이 없을 경우 JPA가 자동으로 변경을 감지하지 않기 때문에 save()를 반드시 호출해야만 DB상에 반영된다.
  - 즉, 트랜잭션이 없는 메서드 내에서 findBy를 해서 데이터를 가져오면, 조회가 끝나자마자 영속성 컨텍스트가 닫힌다.
  - 이후 객체를 setter를 통해 수정하면 이미 영속성 컨텍스트가 끝긴 준영속 상태이기 때문에 메서드가 종료되어도 자동으로 업데이트 쿼리가 나가지 않는다.

<br>

## 4. 플러시(Flush)

"물을 내리다"

영속성 컨텍스트의 변경 내용을 데이터 베이스에 반영(동기화)하는 행위. 지금까지 했던 작업을 임시 저장하는 행동.

### 1) 플러시와 커밋

- 플러시(flush): 작업 중인 내용을 DB에 "전송"만 함. 실제 반영되지는 않음!
  - 임시 저장의 개념. 파일을 쓰다가 Ctrl + S를 한 것과 유사
- 커밋(commit): DB에 전송된 내용을 "확정 짓고 반영"함.
  - 최종 저장의 개념. 파일을 저장하고 닫은 다음 종료하는 행위.
  - 커밋을 하기 전에 내부적으로는 플러시가 먼저 호출된다.

#### (1) 두 액션을 나눈 이유

DB에 데이터를 저장하는 행위를 두 액션으로 나눈 이유는 다음과 같다.

DB에 실제 데이터를 반영하게 되면 롤백 등의 이슈가 발생할 수 있기 때문에, "쿼리를 미리 한 번 던져보고(flush), 문제가 없을 경우에 나중에 확정(commit)하겠다"는 전략.

#### (2) 플러시와 영속성 컨텍스트

플러시는 절대 영속성 컨텍스트를 비우지 않는다!

- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이다.
- 영속성 컨텍스트를 비우거나 닫으면 더 이상 해당 객체는 DB와의 연결 고리가 없기 때문에 사실상 더 이상의 쿼리 수행을 통한 로직 수행이 불가능하게 된다. 영속성 컨텍스트는 작업이 완전히 끝났을 때 비우거나 닫아주는 것이다.
- 플러시가 영속성 컨텍스트를 비우지 않는 이유는 만약에 플러시할 때마다 영속성 컨텍스트를 비워버리면, 한 트랜잭션 내에서 데이터를 수정하고 플러시하고 다시 그 데이터에 뭔가 쓰는 행동을 하려고 할 때 DB에서 데이터를 다시 조회해와야 하는 비효율이 생기기 때문. 메모리를 최대한 활용하기 위한 전략이다.

반면에 커밋을 하게 될 경우에 영속성 컨텍스트가 비거나 닫힌다.

### 2) 플러시 발생 시 일어나는 일들

- 변경 감지(더티 체킹)
- 수정된 엔티티 '쓰기 지연 SQL 저장소'에 등록
- '쓰기 지연 SQL 저장소'의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

#### (1) 영속성 컨텍스트를 플러시 하는 방법

- em.flush() - 직접 호출()
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

#### (2) 플러시 모드 옵션

```java
em.setFlushMode(FlushModeType.AUTO)
```

- FlushModeType.AUTO
  - 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT
  - 커밋할 때만 플러시

### 3) 결론

결국엔 트랜잭션이라는 작업 단위가 중요하다.

<br>
