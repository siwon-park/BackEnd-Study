# 03_영속성 컨텍스트

> Persistence Context

## 1. 영속성 컨텍스트

> JPA를 이해하는데 가장 중요한 용어

"엔티티를 영구 저장하는 환경"이라는 의미

```java
EntityManager.persist(entity);
```

영속성 컨텍스트는 논리적인 개념이기 때문에 눈에 보이지 않는다.

엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다

<br>

## 2. 엔티티의 생명 주기

### 1) 비영속(new, transient)

> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

```java
Member member = new Member();
member.setId = "1L";
member.setName = "siwon-park";
```

위의 Member 타입 객체는 DB나 어떠한 영속성과 관련이 없는 Java에서의 객체이다.

### 2) 영속(managed, persistent)

> 영속성 컨텍스트에 관리되는 상태

```java
// 비영속(new, transient)
Member member = new Member();
member.setId = "1L";
member.setName = "siwon-park";

EntityManager em = emf.createEntityManager();

// 영속(managed)성 상태
em.persist(member); 
```

엔티티 매니저를 통해 일반 java 객체를 persist하게 되면 영속성 컨텍스트에 의해 관리되는 영속성 상태가 된다.

영속성 상태가 되었다고 해서 DB에 저장되지 않으며, 실제 해당 트랜잭션이 커밋되어야만 DB에 저장된다.

### 3) 준영속(detached)

> 영속성 컨텍스와 연관되었다가 분리된(detached) 상태

```java
em.detach(member); // 영속성을 분리함
```

영속성 컨텍스트와 분리되어 준영속 상태가 될 경우 영속성 컨텍스트가 제공하는 기능을 사용하지 못하게 된다.

#### (1) 특징

- 이전에 한 번 영속되었기 때문에 반드시 id를 가지고 있다는 특징이 있다.
  - 위 예시에서 member 객체의 경우, id 값을 getter를 통해 추출할 수 있다.
- 값을 수정해도 더티 체킹(Dirty Checking)이 발생하지 않는다.
  - 영속성 컨텍스트가 관리할 경우 객체의 값만 변경했을 때도 DB 상의 데이터에 변경 사항이 발생할 수도 있으나, 준영속 상태가 되었을 때는 이러한 이벤트가 절대 발생하지 않는다.
- 지연 로딩을 통한 조회가 불가능하다.
  - 지연 로딩을 통해 객체 - 객체의 다리를 건너서 데이터를 조회하는 방식이 불가능하다.
  - 지연 로딩의 원리가 필요할 때 SQL 쿼리를 통해 데이터를 가져오는데, 더 이상 영속성 컨텍스트에 의해 관리되는 객체가 아니기 때문에 쿼리를 수행하지 못한다.
- 준영속 상태의 경우 영속성 컨텍스트와의 관계를 끊었을 뿐, 실제 데이터를 삭제하는 개념이 아니다. 따라서 객체를 준영속 상태로 만들고 트랜잭션을 커밋하더라도 DB상에는 데이터가 남아있다.
  - 준영속 상태의 객체를 .merge() 메서드를 통해서 다시 영속성 상태로 변경할 수도 있다.

#### (2) 준영속화 메서드

엔티티 매니저를 통해 detach(), clear(), close() 메서드를 호출하게 되면 준영속 상태로 변경할 수 있다.

- em.detach(entity)
  - 특정 엔티티만 준영속 상태로 전환
- em.clear()
  - 영속성 컨텍스트를 완전히 초기화 (비우기)
- em.close()
  - 영속성 컨텍스트를 종료
- 트랜잭션이 종료되어 영속성 컨텍스트가 사라졌을 때

### 4) 삭제(removed)

```java
em.remove(member); // 삭제
```

삭제 역시 영속성 컨텍스트가 관리하지 않는다는 점에서 준영속과 비슷하지만, 삭제 상태의 경우 해당 엔티티를 DB에서 삭제하기로 확정된 상태를 의미한다. (삭제 예약 상태)

em.remove(entity)를 호출하는 순간 데이터가 바로 지워지는 것이 아니라, 영속성 컨텍스트 상에서 삭제 대기 상태로 남아 있다가 트랜잭션이 커밋되는 순간 delete 쿼리가 호출된다.

삭제 상태의 경우 준영속 상태와 달리 .merge()를 호출하여 다시 영속성 상태로 만드는 것 자체가 불가능하다. 따라서 새로 만들어야 한다.

<br>

## 3. 영속성 컨텍스트의 이점

캐싱, 버퍼링 등의 이점을 얻기 위해 영속성 컨텍스트라는 매커니즘을 둔 것이다.

### 1) 1차 캐시

영속성 컨텍스트 사용 시 엔티티를 조회할 때, DB에서 바로 조회하지 않고 1차 캐시에서 조회하는 이점이 생긴다.

- 만약 1차 캐시에 없을 경우?
  - DB에서 먼자 찾고 1차 캐시에 저장을 한 다음, 이후에는 1차 캐시에서 찾는다.
    - 물론 찾고자하는 데이터가 DB에 기본적으로 있어야 한다.
  
- 그런데 이런 방식의 캐싱은 성능상 큰 이점을 얻을 수 있다고 볼 순 없다.
  - 왜냐하면 진짜 찰나의 시간에 이루어지는 것이기 때문에 요청이 종료되면 결국 1차 캐시도 사라지기 때문이다.


```java
em.persist(member);

Member findMember = em.find(Member.class, 101L);

// 조회 쿼리문이 나가지 않음 (select id from ..., select name from ... 쿼리 수행 X) -> 1차 캐시에서 조회하기 때문
System.out.println(findMember.getId());
System.out.println(findMember.getName());
```

### 2) 영속성 엔티티의 동일성 보장

일반적인 java 객체의 경우 분명히 같은 객체 같은데 참조하고 있는 주소값이 달라서 서로 다른 객체일 수도 있는 반면, 영속성 컨텍스트를 통해 가져온 엔티티 객체의 경우 조회 조건이 같다면 반드시 동일하다는 특징이 있다.

```java
Member a = em.find(Member.class, "Member1");
Member b - em.find(Member.class, "Member1");

System.out.println(a == b); // true
```

### 3) 트랜잭션을 지원하는 쓰기 지연

트랜잭션을 커밋하는 순간에 SQL문을 보낸다. 쿼리문을 생성하고 "쓰기 지연 SQL 저장소"에 저장해둔 다음 트랜잭션이 커밋되면 DB에 쿼리문을 보낸다.

즉, "저장해줘"라고 명령을 했지만 실제로 DB상에 저장되는 시점은 트랜잭션이 커밋되는 시점인 것이다.

```java
em.persist(memberA);
em.persist(memberB);
// 여기까지 SQL구문을 보내지 않음(JPA가 쌓고 있음)

tx.commit(); // 이 순간에 쿼리문을 보낸다.
```

이렇게 하는 이유는 한번에 모았다가 배치 단위로 보냄으로써 최적화가 가능하다.

### 4) 더티 체킹(Dirty Checking, 변경 감지)

> 엔티티의 상태 변화를 JPA가 감지해서 자동으로 DB에 반영하는 기능

Dirty는 "상태가 변경됨"을 의미한다.

JPA를 쓰는 목적에는 SQL 쿼리문의 동작 및 DB의 데이터를 자바 컬렉션처럼 자유롭게 쓰기 위함인데, 매번 연관된 객체를 save() 메서드를 호출해서 명시적으로 저장해야 한다면 로직/논리상으로 DB와 큰 차이가 없어 굳이 JPA를 써야하나 싶을 수도 있다.

그러나 JPA가 제공하는 더티 체킹을 통해서 (연관 관계에 있는) 데이터를 굳이 저장하지 않아도 트랜잭션 종료 시점에 자동으로 저장할 수 있다.

```java
@Service
public class MemberService {
    
    @Transactional // 필수!
    public void updateMember(Long id, String newName) {
        // 1. 엔티티 조회 (영속성 컨텍스트가 스냅샷 생성)
        Member member = memberRepository.findById(id).get();

        // 2. 값 수정 (자바 객체 내부 값만 바뀜)
        member.setName(newName);

        // 3. save()를 호출하지 않아도 트랜잭션 종료 시점에 자동으로 UPDATE 쿼리 실행!
    }
}
```

#### (1) 동작 원리

- 해당 트랜잭션 내에서 엔티티를 조회를 하면 영속성 컨텍스트에 저장한 다음에, 조회 당시의 스냅샷을 남긴다.
- 이후 엔티티의 필드를 업데이트를 하면, JPA가 1차 캐시, 스냅샷을 탐색하여 변경을 감지한다.
- 트랜잭션이 끝나서 커밋 혹은 flush되는 순간, JPA는 현재 엔티티와 처음에 조회 당시 저장한 스냅샷을 비교하여 차이가 있을 경우 업데이트 쿼리를 작성하여 DB로 보낸다.

#### (2) 동작 조건

- 반드시 영속성 컨텍스트가 관리하는 객체여야 한다.
  - findBy...으로 가져온 객체여야 하며 new 키워드를 통해 새로 생성한 엔티티 객체는 해당되지 않는다.
- 트랜잭션 범위 내에서 있어야 한다.
  - @Transactional 어노테이션이 붙은 메서드 안에서 수행되는 작업이어야만 한다. 트랜잭션이 끝날 때 JPA가 변경사항을 감지하여 동작을 수행하기 때문에 그렇다.

#### (3) 더티 체킹이 동작하는 경우

다음 항목이 모두 Yes로 만족할 경우 더티 체킹에 의해 무조건 저장된다. (명시적으로 save() 호출할 필요 없음)

- 동일 트랜잭션인가? (Yes)
- A의 필드인 B를 영속 상태(DB에서 가져온 상태)인가? (Yes)
  - A를 findBy로 가져온 다음 a.getB()를 호출하여 B를 가져왔을 경우에도 해당 (B도 DB에 이미 있던 데이터)
- B의 필드를 변경하였는가? (Yes)
  - b.setName("XXX")

#### (4) 더티 체킹이 동작하지 않는 경우

다음과 같은 상황에서는 더티 체킹이 동작하지 않기 때문에 반드시 save() 메서드를 명시적으로 호출해야 한다.

- 트랜잭션 밖에서 객체를 수정한 경우
  - 예) 객체를 컨트롤러까지 들고 나갔다가 거기서 setter를 통해 수정했을 경우
  - 이 경우에는 해당 객체는 이미 트랜잭션이 끝난 준영속 상태가 되었기 때문에 JPA가 더 이상 변경 사항을 추적하지 않는다.
- 트랜잭션이 없는 경우
  - 트랜잭션이 없을 경우 JPA가 자동으로 변경을 감지하지 않기 때문에 save()를 반드시 호출해야만 DB상에 반영된다.
  - 즉, 트랜잭션이 없는 메서드 내에서 findBy를 해서 데이터를 가져오면, 조회가 끝나자마자 영속성 컨텍스트가 닫힌다.
  - 이후 객체를 setter를 통해 수정하면 이미 영속성 컨텍스트가 끝긴 준영속 상태이기 때문에 메서드가 종료되어도 자동으로 업데이트 쿼리가 나가지 않는다.

<br>

## 4. 플러시(Flush)

"물을 내리다"

영속성 컨텍스트의 변경 내용을 데이터 베이스에 반영(동기화)하는 행위. 지금까지 했던 작업을 임시 저장하는 행동.

### 1) 플러시와 커밋

- 플러시(flush): 작업 중인 내용을 DB에 "전송"만 함. 실제 반영되지는 않음!
  - 임시 저장의 개념. 파일을 쓰다가 Ctrl + S를 한 것과 유사
- 커밋(commit): DB에 전송된 내용을 "확정 짓고 반영"함.
  - 최종 저장의 개념. 파일을 저장하고 닫은 다음 종료하는 행위.
  - 커밋을 하기 전에 내부적으로는 플러시가 먼저 호출된다.

#### (1) 두 액션을 나눈 이유

DB에 데이터를 저장하는 행위를 두 액션으로 나눈 이유는 다음과 같다.

DB에 실제 데이터를 반영하게 되면 롤백 등의 이슈가 발생할 수 있기 때문에, "쿼리를 미리 한 번 던져보고(flush), 문제가 없을 경우에 나중에 확정(commit)하겠다"는 전략.

#### (2) 플러시와 영속성 컨텍스트

플러시는 절대 영속성 컨텍스트를 비우지 않는다!

- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이다.
- 영속성 컨텍스트를 비우거나 닫으면 더 이상 해당 객체는 DB와의 연결 고리가 없기 때문에 사실상 더 이상의 쿼리 수행을 통한 로직 수행이 불가능하게 된다. 영속성 컨텍스트는 작업이 완전히 끝났을 때 비우거나 닫아주는 것이다.
- 플러시가 영속성 컨텍스트를 비우지 않는 이유는 만약에 플러시할 때마다 영속성 컨텍스트를 비워버리면, 한 트랜잭션 내에서 데이터를 수정하고 플러시하고 다시 그 데이터에 뭔가 쓰는 행동을 하려고 할 때 DB에서 데이터를 다시 조회해와야 하는 비효율이 생기기 때문. 메모리를 최대한 활용하기 위한 전략이다.

반면에 커밋을 하게 될 경우에 영속성 컨텍스트가 비거나 닫힌다.

### 2) 플러시 발생 시 일어나는 일들

- 변경 감지(더티 체킹)
- 수정된 엔티티 '쓰기 지연 SQL 저장소'에 등록
- '쓰기 지연 SQL 저장소'의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

#### (1) 영속성 컨텍스트를 플러시 하는 방법

- em.flush() - 직접 호출()
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

#### (2) 플러시 모드 옵션

```java
em.setFlushMode(FlushModeType.AUTO)
```

- FlushModeType.AUTO
  - 커밋이나 쿼리를 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT
  - 커밋할 때만 플러시

### 3) 결론

결국엔 트랜잭션이라는 작업 단위가 중요하다.

<br>

## 5. save() 메서드

JPA의 기본 메서드 중 저장을 위한 메서드에는 save()와 saveAll()이라는 메서드가 존재한다.

### 1) save()의 리턴 값

이 두 메서드의 경우 반환 타입이 void가 아님을 유의해야 한다.

또한 가장 중요한 것은 이 두 메서드의 반환 결과로 리턴된 객체는 영속성 컨텍스트에 의해 관리되는 객체라는 점이다.

save()를 호출하고 반환된 객체는 영속성 컨텍스트가 관리하는 객체임을 증명한 객체이다.

따라서 이 객체를 @Transactional 범위 내에서 수정할 경우 더티 체킹에 의해서 객체가 변경될 경우 자동으로 업데이트 쿼리를 날려준다.

#### (1) persist()와 merge()

save 메서드 호출 시 내부적으로는 persist()와 merge() 메서드를 호출한다.

- persist(): 새로운 엔티티를 생성
- merge(): 이미 존재하는 엔티티의 수정
  - merge()의 동작 방식: 전달받은 객체를 바로 영속성 컨텍스트에 집어 넣는 것이 아니라, 똑같은 내용의 새로운 영속성 객체를 복사하여 반환함.

#### (2) Java 객체와의 차이

save() 메서드에 인자로 넣은 객체와 save() 메서드를 통해 리턴받은 객체는 서로 다른 별개의 객체이다.

이미 DB에 존재하는 데이터를 findBy로 가져왔을 때는 동일하게 영속성 컨텍스트에 의해 관리되지만, 새로 생성한 경우에는 리턴받은 객체만 영속성 컨텍스트에 의해서 관리되는 객체이다.

### 2) save() 직후 id 확인

엔티티의 id 생성 전략에 따라 다르지만, 대부분의 경우에는 save 메서드 호출 이후 리턴받은 객체에서 id를 확인할 수 있다. 반면 직접 새로 생성한 객체의 경우 아직 DB상에 반영되지 않았기 때문에 id 값은 null이다.

"@Transactional에 의해 트랜잭션으로 묶여있으면 save를 해도 아직 실제 DB에는 반영되지 않은 것 아닌가?"라고 생각하지만, 실제 이 부분은 전략과 Hibernate의 동작에 의해서 생각한 것과 달리 동작한다.

#### (1) DB 반영과 트랜잭션 커밋의 차이

- 플러시 (Hibernate의 동작)
  - 원래 원칙대로라면 트랜잭션이 다 끝나는 순간 한 번에 모든 것을 처리하지만,
  - save() 메서드를 호출하면 즉시 insert 쿼리가 DB로 전송된다. (플러시)
  - DB는 이 쿼리의 호출 결과로 임시적(아직 커밋되지 않았으니)으로 데이터를 들고 있고, id도 발급하여 준다.
- 트랜잭션 커밋
  - 메서드가 끝나는 순간, 플러시의 수행으로 보낸 쿼리의 수행 결과를 진짜로 반영하여 확정한다.

즉, 트랜잭션이 커밋되지 않아도 플러시로 인해서 반영될 id를 확인할 수 있게 된다.

만약 save() 이후에 에러가 발생하여 해당 트랜잭션이 롤백되어야 할 경우에는 DB는 플러시를 통해 받은 insert 쿼리를 취소한다. 이 때 java 객체에는 플러시를 통해 리턴받은 id를 갖고 있지만, 롤백되었기 때문에 해당 id는 유효하지 않은 유령 id가 된다.

#### (2) GenerationType.IDENTITY

MySQL, MariaDB에서 사용하는 PK 생성 전략으로, save() 호출 시, 즉시 insert 쿼리가 수행(플러시)되어 ID를 확인할 수 있다.

#### (3) GenerationType.SEQUENCE

Oracle, PostgreSQL에서 사용하는 PK 생성 전략으로, save() 호출 시 Hibernate가 DB의 시퀀스 객체에서 다음에 부여될 번호만 먼저 가져온다.

아직 insert 쿼리는 수행되지 않았지만, 시퀀스에서 가져온 값으로 객체의 id를 채워서 이후의 동작을 가능하게 한다.

## 6. find 메서드

### 1) save() 직후 find() 메서드

save() 호출 직후 find 메서드를 통해 영속성 컨텍스트를 가져오면 JPA는 기본적으로 DB를 뒤지지 않고 1차 캐시에서 데이터를 가져온다.

- save()를 호출하면 메모리(1차 캐시)에 영속성 컨텍스트가 관리하는 객체를 저장, 이후에 find 메서드 호출 시 해당 객체를 메모리에서 가져온다.
- 여기서 id 생성 전략에 따라 플러시 호출 시점의 차이가 있는데, IDENTITY일 경우에는 save() 호출 시점에 flush하고, 아닐 경우에는 find 메서드 중 기본 메서드인 findById()가 아닌 find 메서드를 호출할 때에 flush를 호출한다.
  - 전반적으로 find 메서드를 실행하기 직전에 오토 플러시(auto flush)가 수행된다고 이해하면 된다.
