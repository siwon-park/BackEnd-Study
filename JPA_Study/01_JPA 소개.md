# 01_JPA 소개

## SQL 중심적인 개발의 문제점

### 무한 반복, 지루한 코드

자바 객체를 SQL로, SQL을 자바 객체로...(무한 반복)

자바 객체의 수정 => 쿼리문 수정

SQL 의존적인 개발을 피하기 어려움



### 패러다임의 불일치

객체 지향적 사고와 관계형 데이터베이스의 사고가 다름

객체 지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속 등의 객체지향적 사고를 지향한다\

관계형 데이터베이스의 목적은 데이터를 잘 저장하는 것



### 객체와 관계형 데이터 베이스의 차이

1. 상속 => 객체는 상속이 있지만, 관계형은 없음(슈퍼타입-서브타입 관계는 있음)
   - 객체의 상속관계를 테이블에 맵핑하려면 쿼리문을 2번 작성해야함
2. 연관관계 => 객체는 참조를 통해 연관관계를 가져올 수 있지만, 관계형은 PK, FK, JOIN 등을 활용함
   - 객체는 역참조가 불가능 할 때가 있지만, 관계형은 참조/역참조가 가능함



#### 엔티티의 신뢰성 의문

엔티티를 다른 사람이 만들었을 때, 해당 쿼리문에 대해서 잘 알지 못하니 함부로 메서드를 통해 호출을 하기에는 신뢰성이 떨어짐



결국 객체 답게 모델링을 할 수록 맵핑 작업만 늘어남

<br>

## JPA

### Java Persistence Api

#### ORM

Object Relational Mapping(객체 관계 맵핑)

객체는 객체대로 설계하고, 관계형 데이터베이스는 관계형 데이터베이스대로 설계하고, ORM 프레임워크가 중간에서 이를 맵핑시켜줌



#### 구조 및 동작

JPA는 어플리케이션과 JDBC 사이에서 동작하는 구조

쿼리를 만들고 JDBC API를 활용해서 맵핑 => **패러다임의 불일치 해결**



### JPA는 표준 명세

#### JPA는 인터페이스의 모음

JPA는 **Hibernate**, EclipesLink, DataNucleus 구현체를 구현한 **표준 인터페이스**



### JPA를 사용해야하는 이유

#### 생산성

이미 만들어진 코드를 불러와서 쓰면 됨

#### 유지보수

필드를 추가해도 따로 쿼리문을 수정할 필요가 없음

#### 패러다임의 불일치 해결

객체와 관계형 데이터 베이스의 패러다임 불일치를 해결(상속, 연관관계 등)

엔티티의 신뢰성 문제 해결 => 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장

#### 성능

3가지 최적화 기능 제공

- 1차 캐시와 동일성 보장
  - 같은 트랜잭션 안에서는 같은 엔티티를 반환
- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 커밋할 때까지 INSERT SQL을 모아서 JDBC BATCH SQL 기능을 사용해 한번에 SQL 전송
- 지연 로딩과 즉시 로딩(옵션으로 선택 가능)
  - 지연 로딩: 객체가 실제 사용될 때 로딩
    - 예) memberDAO에서 뭔가 가져왔을 때는 Member에 대해서만 SELECT 해오다가, 뭔가 Member와 연관된 다른 테이블이 필요할 때 그 때 SELECT 해옴
  - 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회

#### 데이터 접근 추상화와 벤더 독립성

#### 표준



## 요약

JPA를 배우더라도 RDB을 잘해야함

ORM은 객체와 RDB를 연결해주는 역할임

객체(프레임워크, 언어)는 다른 것으로 대체될 수 있지만, 데이터를 저장하는 RDB는 바뀌지 않을 가능성이 매우 매우 높음. 따라서 RDB에 대한 공부도 계속해서 해줘야함