# 02_Kafka

> 아파치 카프카(Apache Kafka)

## 1. 개요

### 1) 왜 카프카인가? (Why Kafka?)

Source App에서 발생한 데이터를 Target App에 전달해주는 구조라고 하자.

그런데 만약에

- Target App이 늘어나고 Source App도 늘어난다면? → 구조가 복잡해진다면? 
- 클릭 로그, 결제 로그, 접속 로그 등 다양하게 대량으로 발생되는 이벤트 로그들을 다뤄야 한다면?
- 데이터를 Target에게 직접 전달하는 방식은 데이터 유실 가능성이 존재한다.
- 그럼 DB와 같은 미들웨어를 두는 방식은 어떨까? 일반적인 DB와 같은 데이터 적재 방식은 데이터 유실 가능성, 리소스(DB커넥션 풀 등), 쿼리 최적화 등으로 인해 이벤트와 같은 빅 데이터를 다루기 부적합하다.

<br>

### 2) 기본 구조

로그와 같은 이벤트 데이터를 생성하는 Source App을 생산자(프로듀서, Producer)라고 한다.

프로듀서는 생성된 이벤트들을 이벤트 브로커(Event Broker)인 카프카에게 보낸다.

카프카에 저장된 이벤트들은 소비자(컨슈머, Consumer)라고 불리는 Target App에서 적절한 규칙에 따라 소비(Consume)한다.

즉, 미들웨어가 데이터를 보내는 것이 아니라 필요한 어플리케이션이 미들웨어에 쌓인 데이터를 가져오는 방식으로 동작하며, 특이한 점으로는 카프카에 쌓인 이벤트는 소비자가 소비한다고 해서 삭제되지 않고 (일정 기간) 보관된다.

- 흔히 카프카를 메세지 브로커로 오해하는 경우가 있는데, 엄밀히 말해 카프카는 이벤트 브로커이다. 물론 카프카가 메세지 브로커 역할을 할 수도 있긴 하다. 하지만 메세지 브로커의 메시지는 소비되면 삭제되는 반면 이벤트 브로커는 이벤트들이 소비되더라도 삭제되지 않는다.

카프카 이벤트 브로커는 1개가 아니다. 이벤트 브로커는 여러 개일 수도 있다. 그래서 카프카 클러스터(Kafka Cluster)라고 부른다.

<br>

## 2. 카프카 핵심 컴포넌트

### 1) 토픽(Topic)

이벤트 브로커 내 존재하는 큐와 같은 개념(메세지 브로커의 메세지 큐와 같은 개념)

토픽은 여러 개의 파티션으로 구성되어 있으며, 목적에 따라 어떤 데이터를 넣는지 명시적으로 명명하여 유지보수, 운용에 효율성을 가져갈 수 있다.

### 2) 파티션(Partition)

토픽 내에 존재하는 여러 개의 작은 큐와 같은 개념이다.

토픽 자체가 큐이기도 하지만, 파티션을 나누는 핵심적인 이유는 데이터를 병렬로 빠르게 분산 처리하기 위함이다.

만약에 한 토픽의 파티션을 하나의 브로커에 배치할 경우, 해당 토픽의 성능은 브로커의 I/O 성능에 의해 좌우된다.

토픽을 파티션으로 나누고 여러 브로커에 배치함으로써 이벤트들을 병렬적으로 빠르게 분산 처리할 수 있게 된다. (토픽의 수평적 확장)

#### (1) 파티션의 특징

- 파티션은 늘렸다가 다시 줄일 수 없다.
- 새로운 이벤트가 프로듀서에 의해 전달되면 특별한 설정이 없는 이상 카프카 클러스터가 각 파티션에 라운드-로빈 방식으로 할당한다.
- 이벤트의 보존 기간은 파티션의 데이터 보존 기간 혹은 보존 크기에 따라 달라진다.
- 컨슈머는 파티션에 가장 오래된 순서의 데이터부터 순차적으로 가져간다. (매번 다시 처음부터 가져가는 형태는 아님)
- 컨슈머가 데이터를 가져가더라도 파티션에서 데이터가 삭제되지 않는다.
- 새로운 컨슈머(그룹)가 카프카 클러스터에 붙으면 다시 0번부터 데이터를 소비한다.

### 3) 브로커

카프카가 설치된 서버의 단위를 브로커라고 한다.

일반적으로 3개 이상의 브로커를 권장한다.

### 4) 레플리카(레플리케이션)

파티션의 복제. 한 브로커에 파티션의 원본(리더 파티션)이 있고, 이에 대한 복제들(팔로워 파티션)이 다른 브로커에 존재함.

- 리더 파티션을 통해서만 읽기와 쓰기가 가능하다.
- 팔로워들은 리더 파티션에 이슈가 생길 경우 리더를 승계하여 동작하기 위해 존재한다.

레플리케이션의 수는 원본을 포함한 개수를 의미한다. 따라서 레플리케이션 수가 1이라는 것은 원본 밖에 없다는 의미이다.

따라서 레플리케이션의 수는 브로커의 수를 초과할 수 없다. (실제 설정상으로도 그러하다.)

#### (1) 레플리케이션을 사용하는 이유? (why replication?)

카프카 고가용성의 핵심.

- 브로커가 3개인데, 파티션이 1개, 리플리케이션이 1개라면?
  - 리더 파티션이 있는 서버가 물리적으로 공격을 받은 상태라면 사실상 복구 불가
- 그러나 레플리케이션이 2개 이상이라면 팔로워 파티션이 리더 파티션을 승계하여 리더로서 동작할 수 있어 데이터 유실 걱정이 없다.

하지만 레플리케이션의 수가 많으면 아무래도 서버 리소스 사용량이 늘어날 수 밖에 없기 때문에 적정 레플리케이션의 수를 정하는 것이 좋다.

- ACK 옵션
  - 프로듀서가 브로커에게 데이터를 보낼 때 사용하는 옵션
  - 0: 리더 파티션에 데이터를 보내고 응답을 받지 않음. 응답을 받지 않으니 속도가 빠르나 데이터 유실 가능성이 존재.
  - 1: 리더 파티션에 데이터를 보내고 응답을 받는다. 그러나 리더 파티션에 대해서만 응답을 받기 때문에 나머지 파티션에 대해서는 응답 결과를 알 수 없어 데이터 유실 가능성이 존재한다. (만약 리더 전송 이후 장애가 발생한다면?)
  - all: 나머지 파티션에 대해서도 데이터를 정상적으로 받았는지 응답을 받음. 모든 파티션에 대한 응답을 받으니 속도가 느릴 수 밖에 없음

#### (2) ISR (In Sync Replica)

리더 파티션과 팔로워 파티션은 ISR이라는 논리적인 그룹으로 묶여 있는데, ISR 그룹에 속하지 않은 팔로워 파티션은 리더 파티션을 승계할 자격이 없다.

ISR로 리더와 팔로워를 그룹화한 이유는 팔로워 역시 리더로부터 데이터를 복제(백업)하는데 완전한 상태로 존재할 수 없다. (태생적으로 리더가 아니기 때문에 불완전한 상태일 수 밖에 없음)

만약에 불완전한 팔로워 파티션이 리더를 승계하여 리더가 된다면 데이터 정합성, 메세지 손실 등과 같은 치명적인 문제가 발생할 수 있다.

따라서 리더는 만약에 특정 팔로워가 설정된 주기의 시간 동안의 복제 요청을 수행하지 않는다면 레플리케이션 동작에 문제가 있다고 판단하고 ISR 그룹에서 추방하여 리더가 될 자격을 박탈한다.