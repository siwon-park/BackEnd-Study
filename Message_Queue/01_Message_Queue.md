# 01_메세지 큐(Message Queue)

## 1. 메세지 지향 미들웨어(MOM)

### 메세지(Message)

> 요청, 응답, 오류 등 단순한 정보의 작은 데이터

<br>

### 메세지 지향 미들웨어(Message Oriented Middleware: MOM)

> 메세지 API를 통해 각 분산되어있는 애플리케이션 간의 다리 역할을 함으로써 데이터(비동기식 메세지)를 교환할 수 있도록 하는 소프트웨어(미들웨어)

![image](https://user-images.githubusercontent.com/93081720/233535554-270ed84a-eaea-43f2-8495-591427a5c025.png)

#### MOM의 특징

- 비동기 방식으로 메세지를 전달함
- 메세지를 발행하는 `발행자(Publisher)` 또는 `생산자(Producer)`와 메세지를 소비하는 `구독자(Subscriber)` 또는 `소비자(Consumer)`로 이루어져 있음

<br>

#### MOM의 장점

- 메세지를 전달하는 과정에서 보관, 라우팅, 변환할 수 있는 장점을 가지고 있음
  - 보관: 메세지의 백업을 통해 지속성을 유지하여, 송수신 측에서 항상 네트워크를 유지할 필요가 없다
  - 라우팅: 미들웨어 계층 자신이 직접 메세지를 라우팅할 수 있어 메세지를 여러 수신자에게 배포가 가능함(`멀티 캐스팅`) 
  - 변환: 송수신 측의 요구에 따라 메세지를 변환 가능

<br>

#### MOM의 단점

- 일반적인 백엔드 어플리케이션 서버는 기본적으로 동기 방식으로 통신하지만, MOM은 비동기 방식으로 통신하여 통신 매커니즘의 불일치가 발생함
- 새로운 외부 요소의 추가로 시스템 성능 저하, 신뢰성이 떨어지게 됨
  - 아키텍처 외부 구성 요소인 메세지 전송 에이전트가 추가된 것이기 때문

- 시스템의 복잡성이 증가하여 관리가 어렵고 비용이 증가함

<br>

## 2. 메세지 큐(Message Queue: MQ)

> 메세지 지향 미들웨어(MOM)을 구현한 시스템으로, 프로그램(프로세스) 간 데이터를 교환할 때 사용하는 기술

<img src="https://user-images.githubusercontent.com/93081720/233534989-629ce70e-968b-4546-9df0-c4372fd81cb0.png" referrerpolicy="no-referrer" alt="image" height="400">

### 구성

크게 메세지를 생성하는 `Producer`와 메세지를 큐잉 또는 대신 전달하는  `Message Queue` 또는 `Broker`, 메세지를 소비하는 `Consumer`로 이루어져 있다.

![image](https://user-images.githubusercontent.com/93081720/233791606-74885035-df26-4c9d-92c9-14b372ce6715.png)

<br>

### AMQP(Advanced Message Queuing Protocol)

>  메세지를 교환할 때 사용하는 프로토콜(Protocol)

메세지 지향 미들웨어를 위한 개방형 표준 응용 계층 프로토콜로, 메세지 큐가 메세지 전달을 위해 사용하는 프로토콜이다.

<br>

### MQ의 장점

- 비동기(Asynchronous)
  - 데이터를 수신자에게 바로 보내지 않고, 큐에 넣어서 관리하다가 나중에 보냄
- 비동조(Decoupling)
  - 메세지 큐 역할을 하는 시스템이 어플리케이션과 분리되어 있어 종속적이지 않기 때문에 확장이 용이함
- 탄력성(Resilience)
  - 메세지 전달이 실패할 수 있으나, 이것이 시스템 전체에 영향을 주지 않음
- 과잉(Redundancy)
  - 실패한 작업을 재실행 가능함
- 보증(Guarantees)
  - 작업이 처리된 것을 확인 가능함
- 확장성(Scalable)
  - `N:1:M` 구조로 다수의 프로세스들이 큐에 메세지를 보낼 수 있음

<br>

### MQ의 단점

- 큐가 가득 차서 더이상 큐에 메세지를 저장할 수 없는 상황이면 메세지를 다른 곳에 보존해야 하거나, 버려야 함

<br>

### MQ의 사용처

만약 1만 개의 요청이 한꺼번에 들어오고 이를 받자마자 순차적으로 처리한다면, 서버에 순간적으로 부하(트래픽)이 몰려서 서버의 성능 저하를 가져올 수도 있으나, MQ를 사용한다면 서버는 서버가 처리할 수 있는 양만큼 처리하고 나머지는 MQ에 보내서 나중에 MQ가 처리할 수 있게 환다면 서버의 부담을 줄일 수 있음

|                          MQ 사용 전                          |                           MQ 사용                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/93081720/233793308-0ab5f68e-de3d-4121-96e5-8c9ecb562a2f.png) | ![image](https://user-images.githubusercontent.com/93081720/233793341-effa709f-d132-4ea4-b44f-26aff90e6919.png) |

#### 어플리케이션 / 시스템 간 통신(서버 다운 대비)

시스템 간 통신을 할 때, 항상 시스템 장애를 생각해야 한다. 만약 서버가 점검 및 문제로 갑자기 다운되어 버리면 다운타임 동안에는 요청을 주고 받을 수 없다.

이때 만약 MQ를 사용한다면, 소비자(Consumer)가 메세지를 받을 수 없는 상태더라도 MQ에 메세지를 보관해 뒀다가 소비자가 메세지를 받을 수 있는 상태가 되면 메세지를 전달하면 된다.

<br>

#### 서버 부하가 많은 작업

이미지 처리, 비디오 인코딩, 빅데이터 등 대용량 데이터 처리 작업은 메모리와 CPU를 많이 사용한다. 이러한 작업들은 동시에 처리할 수 있는 양이 한정적이어서 무작정 요청을 보내서 처리한다면, 서버에 부하를 줘서 성능 저하를 가져오게 된다.

이 경우에도 MQ를 사용하여 서버가 처리할 수 있는 양의 일부를 MQ가 처리하고, 서버는 서버가 처리할 수 있는 양만큼 처리함으로써 서버의 안정성을 가져올 수 있다.

<br>

#### 부하 분산

메세지를 받을 수 있는 Consumer를 여러 개 배치해서, 부하를 분산시키고 원하는 데이터를 처리할 수 있게 한다. 이러한 구조는 수평적 확장(Horizontal Scaling)에 유리하다.

<br>

#### 데이터 손실 방지(데이터 백업)

MQ로부터 가져온 메세지를 일정 시간이 지나도록 처리했다고 다시 MQ에 알려주지 않으면 MQ는 이를 다시 큐에 넣어서 처리한다. 따라서 데이터 백업이 가능하다.

