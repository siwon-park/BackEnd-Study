# 09_객체 배열과 기본형 배열

Java로 알고리즘 문제를 풀다가 거의 유사한 풀이인데, 메모리 사용량이 2배 차이났다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/c2274a86-9f83-4c74-918e-9e2053859814)

왜 그런지 이유를 찾아보니, 객체 배열의 동작 방식에서 그 원인을 찾을 수 있었다.

(두 풀이의 차이는 객체 배열을 사용하는가, 기본형 다차원 배열을 사용하는가에 있었다.)

- 메모리 사용량이 2배인 코드는 `Pair`클래스를 선언하여 객체 배열을 사용하고 있었다.

```java
class Pair {
    long sum;
    long val;
}

Pair[] tree = new Pair[N * 4];
```

반면에, 메모리 사용량이 적은 코드는 2차원의 기본형 배열을 사용하였다.

- 메모리 사용량이 적은 코드

```java
long[][] tree = new long[N * 4][2];
```

<br>

## 1. 객체 배열의 동작 구조

객체 배열은 `각 요소가 객체를 참조하는 형태`로 메모리에 할당됨

- 각 요소는 실제 객체의 메모리 주소를 참조함
- 객체 배열은 객체의 크기와 상관 없이 각 요소는 일정한 크기를 갖고 있음
- 따라서 메모리 상에서 객체를 참조하는 공간과 실제 객체가 할당된 공간으로 구성됨



객체 배열을 초기화할 때 `new`키워드를 사용하여 초기화 → `heap`영역에 할당됨

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/8c80c0d7-ff24-46f3-9425-2a9b0ab2cde8)

<br>

배열의 각 인덱스에 Pair 객체를 생성하여 할당하기 위해 `new`키워드를 사용 → `heap`영역에 할당됨

실제 객체의 값이 저장된 공간이 있고, 객체 배열에는 해당 객체를 참조하기 위한 주소값이 할당되어 있음

- 객체 배열의 각 요소는 객체의 주소를 담기 위해 객체 크기와 상관없이 일정한 크기를 가지고 있음
- 실제 객체가 저장된 곳과 객체 배열의 각 요소가 갖고 있는 일정한 크기의 값이 메모리에 올라가 있으므로 메모리 사용량이 더 많음

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/9153cd97-1058-4daa-a165-c3a456854507)

객체 배열은 유연성과 다양한 객체를 저장할 수 있다는 장점이 있지만, 각 요소마다 객체를 참조하는 공간이 추가적으로 필요하기 때문에 메모리 사용량이 상대적으로 커진다는 단점이 있음

<br>

## 2. 기본형 배열의 동작 구조

기본형 배열은 `배열의 각 요소들이 연속적으로 메모리에 할당되는 형태`로 구성됨

- 기본형 배열은 각 차원의 크기에 따라 메모리에 연속적으로 공간이 할당되므로 인덱스를 통해 요소에 접근이 가능함
- 각 요소의 크기에 따라 메모리 사용량이 결정됨
- 각 요소들이 연속적으로 할당되므로 참조를 위한 추가적인 공간이 별도로 필요하지 않음

따라서 기본형 배열, 기본형 다차원 배열은 메모리 사용량이 객체 배열에 비해 상대적으로 작다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/9be3f99e-69de-46d4-9dea-bd07c675c07d)

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/5fca3bbe-75ad-424c-b8a6-632cb9aff49e)

<br>