# 11_자바 문자열 비교

자바에서의 문자열 비교 시 유의할 점 정리

## 1. 객체비교 (==)

비교 연산자 `==`을 통해서도 문자열 간 일치 비교를 할 수는 있으나, 정확한 내용을 비교하고자 한다면 부적절한 방법이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/0f854ae3-df07-44ed-a95c-c5bdb5b7ba3c)

위와 같이 `word1`과 `word3`는 같은 내용을 가진 문자열 객체임에도 불구하고 `false`가 출력됨을 알 수 있다.

따라서 `==`은 같은 `객체인지를 비교하는 데 사용`하는 것이 적절하다.

### 문자열 풀(String Pool)

그러면 `word1`과 `word2`는 왜 같음(`true`)으로 나올까?

바로 문자열 풀(String Pool)이라는 개념 때문이다.

문자열 풀은 Java에서 문자열 리터럴을 저장하고 관리하는 특별한 영역으로, JVM내에 위치해 있다.

- ※ 문자열 리터럴은 `""(쌍따옴표)`로 감싸져 있는 글자 그대로의 문자열을 의미한다.

문자열 풀의 존재 목적은 `문자열의 중복을 피하고 메모리를 절약`하기 위함이다.

JVM은 문자열 리터럴을 만나면 문자열 풀을 확인하고, 동일한 내용의 문자열이 이미 존재하면 해당 문자열의 참조를 반환한다. 그렇기 때문에  `word1`과 `word2`가 같은 객체이기 때문에 `true`가 반환되는 것이다.

이러한 동작의 이유에는 `String 클래스가 불변(immutable)하다`는 특징과 관련 있다.

`한 번 생성된 문자열은 변경할 수 없기 때문에, 같은 내용의 문자열이라면 메모리에서 한 번만 생성하고 재사용하는 것이 효율적`이다.

어차피 변경할 수 없는 객체를 같은 값임에도 불구하고 한 번 더 생성하여 메모리에 올리는 행동은 비효율적일 수 밖에 없다. 왜냐하면 그 객체에 문자열 변경이나 어떤 작업을 한다고 하면 String 클래스가 불변 객체이니 문자열 변경이 완료된 혹은 다른 작업이 완료된 새로운 문자열 객체를 메모리에 올려야 하는 것은 똑같기 때문이다.

따라서 문자열 풀을 사용하여 `문자열 리터럴 방식으로 생성한 String 객체는 같은 객체`이고, 문자열 풀을 사용하지 않고 `new 키워드를 통해 생성한 문자열 객체는 다른 객체`가 된다.

<br>

## 2. 값 비교 (eqauls)

올바르게 값의 내용만을 비교하고 싶다면 `equals`를 사용해야 한다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/14661a54-c8db-485c-8d7c-af5780c1c304)

`new` 키워드를 통해 문자열 객체를 생성했음에도 불구하고 같은 값을 가졌기 때문에 `true`가 출력됨을 확인할 수 있다.

<br>

## 3. 대소 비교 (compareTo)

문자열 간의 일치 비교가 아니라 대소 비교, 즉 사전 순으로 어떤 문자가 더 빨리 오는지 등을 확인하고 싶다면 `compareTo`메서드를 사용해야 한다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/0ed346eb-a30a-48ac-9fea-9119b10fb43f)

자바의 정렬과 마찬가지로 나오는 결과가 같다고 보면 된다.

자바 정렬에서 기본은 `오름차순`이기 때문에 `양수`가 나오면 자리를 바꿈, `0`이면 같음, `음수`면 이미 오름차순이기 때문에 변경할 필요 없음과 같은 로직이다.

`A.compareTo(B)`에서

- 반환값이 `음수`이면 compareTo를 `호출한 객체가 더 앞에 있다`는 의미이다. (`A < B`)
- 반환값이 `0`이면 두 문자열이 동일하다는 의미이다. (`A = B`)
- 반환값이 `양수`이면 compareTo의 `매개변수로 온 문자열이 더 앞에 있다`는 의미이다. (`A > B`) 